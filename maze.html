<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Maze – Scientific Lab Preview (v4)</title>
  <meta name="description" content="Lightweight pseudo‑3D raycast maze: WASD move, mouse look, space jump, click to shoot. Optimized floor + crisp walls." />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <style>
    :root { --bg:#06101a; --panel:#0d1824; --accent:#22d3ee; --warn:#ff925d; --danger:#ff4d55; --ok:#35d07f; --radius:20px; }
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:system-ui,-apple-system,Inter,Segoe UI,Roboto,sans-serif;background:radial-gradient(900px 600px at 12% 8%,#12273b,#060c14 70%);color:#e6edf3;min-height:100vh;display:flex;flex-direction:column;}
    body.playing{overflow:hidden}
    body.playing header{display:none}
    body.playing main{padding:0}
    body.playing .game-shell{width:100vw;height:100vh;margin:0}
    body.playing canvas{width:100vw!important;height:100vh!important;border-radius:0;border:none;box-shadow:none;max-width:none;}

    header{padding:14px clamp(16px,4vw,40px);display:flex;justify-content:space-between;align-items:center;gap:20px;background:rgba(8,16,26,.7);backdrop-filter:blur(14px) saturate(160%);border-bottom:1px solid #163044;position:sticky;top:0;z-index:50}
  header h1{font-size:clamp(1.05rem,2.6vw,1.45rem);line-height:1.1;margin:0;background:linear-gradient(90deg,#22d3ee,#6bc8ff);-webkit-background-clip:text;background-clip:text;color:transparent;font-weight:650;letter-spacing:.5px}
    header nav a{color:var(--accent);font-size:.7rem;font-weight:600;letter-spacing:.7px;text-transform:uppercase;text-decoration:none;display:inline-flex;align-items:center;gap:6px;padding:10px 14px;border:1px solid rgba(255,255,255,.14);border-radius:14px;background:rgba(255,255,255,.04);transition:.45s}
    header nav a:hover{background:rgba(255,255,255,.12)}

    main{flex:1;display:grid;place-items:center;padding:24px clamp(10px,4vw,50px) 60px;}
    .game-shell{position:relative;display:flex;flex-direction:column;align-items:center;gap:12px}
    canvas{background:#050c14;border:1px solid #1b3143;border-radius:18px;box-shadow:0 10px 34px -14px rgba(0,0,0,.75),0 0 0 1px rgba(34,211,238,.25);image-rendering:pixelated;max-width:100%;cursor:crosshair;}

    .hud{position:absolute;top:8px;left:8px;display:flex;flex-direction:column;gap:4px;font-size:.62rem;font-weight:500;letter-spacing:.5px;pointer-events:none;text-shadow:0 2px 6px #000c}
    .hud span{display:inline-flex;gap:6px;align-items:center;background:rgba(0,0,0,.35);padding:4px 8px;border:1px solid rgba(255,255,255,.15);border-radius:10px}
    
    /* Helmet HUD Style */
    .helmet-hud-top{position:absolute;top:0;left:0;right:0;height:80px;background:linear-gradient(180deg,rgba(0,0,0,.8),rgba(0,0,0,.4) 70%,transparent);pointer-events:none;z-index:30;border-radius:0 0 15px 15px;display:flex;justify-content:center;align-items:center;padding:10px 20px;}
    .helmet-hud-bottom{position:absolute;bottom:0;left:0;right:0;height:100px;background:linear-gradient(0deg,rgba(0,0,0,.8),rgba(0,0,0,.4) 70%,transparent);pointer-events:none;z-index:30;border-radius:15px 15px 0 0;display:flex;justify-content:space-between;align-items:flex-end;padding:15px 20px;}
    
    .compass{display:flex;flex-direction:column;align-items:center;gap:8px;color:#22d3ee;font-size:.65rem;font-weight:600;text-shadow:0 0 4px rgba(34,211,238,.8);}
    .compass-rose{position:relative;width:60px;height:60px;border:2px solid rgba(34,211,238,.6);border-radius:50%;background:radial-gradient(circle,rgba(34,211,238,.1),transparent 70%);}
    .compass-directions{position:absolute;inset:-8px;font-size:.5rem;font-weight:700;}
    .compass-n{position:absolute;top:0;left:50%;transform:translateX(-50%);color:#ff6b6b;}
    .compass-s{position:absolute;bottom:0;left:50%;transform:translateX(-50%);color:#6bcf7f;}
    .compass-e{position:absolute;right:0;top:50%;transform:translateY(-50%);color:#ffd93d;}
    .compass-w{position:absolute;left:0;top:50%;transform:translateY(-50%);color:#ff9f43;}
    .compass-needle{position:absolute;top:50%;left:50%;width:2px;height:25px;background:linear-gradient(180deg,#ff6b6b,#22d3ee);transform-origin:bottom center;transition:transform .3s ease;}
    
    .hydrogen-pointer{position:absolute;top:50%;left:50%;width:20px;height:20px;margin:-10px;border:2px solid #8b5cf6;border-radius:50%;background:rgba(139,92,246,.2);transform-origin:center;animation:pulse 2s infinite;}
    .hydrogen-pointer::after{content:"H";position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:.6rem;font-weight:700;color:#8b5cf6;}
    @keyframes pulse{0%,100%{transform:scale(1);opacity:.8}50%{transform:scale(1.2);opacity:1}}
    
    .minimap-container{width:80px;height:80px;border:2px solid rgba(34,211,238,.6);border-radius:8px;overflow:hidden;background:rgba(0,0,0,.3);}
    .minimap-container canvas{width:100%;height:100%;display:block;}
    
    .status-info{display:flex;flex-direction:column;gap:4px;color:#e6edf3;font-size:.6rem;text-shadow:0 2px 4px #000;}
    .status-info span{display:flex;align-items:center;gap:6px;background:rgba(0,0,0,.4);padding:4px 8px;border:1px solid rgba(255,255,255,.2);border-radius:6px;}
    .crosshair{position:absolute;top:50%;left:50%;width:16px;height:16px;margin:-8px 0 0 -8px;pointer-events:none;opacity:.65}
    .crosshair:before,.crosshair:after{content:"";position:absolute;background:#fff;border-radius:2px}
    .crosshair:before{left:7px;top:0;width:2px;height:16px}
    .crosshair:after{left:0;top:7px;height:2px;width:16px}

    .overlay{position:absolute;inset:0;display:grid;place-items:center;background:linear-gradient(130deg,rgba(9,18,30,.88),rgba(9,18,30,.72));backdrop-filter:blur(10px) saturate(180%);border-radius:18px;animation:fadeIn .6s ease;z-index:40;transition:opacity .5s ease,filter .5s ease}
    .overlay.hidden-force{display:none !important;opacity:0 !important;filter:none !important}
    @keyframes fadeIn{from{opacity:0}to{opacity:1}}
    .menu{display:flex;flex-direction:column;align-items:center;gap:18px;max-width:340px;text-align:center}
  .menu h2{margin:0;font-size:1.25rem;letter-spacing:.5px;font-weight:620;background:linear-gradient(90deg,#22d3ee,#76d6ff);-webkit-background-clip:text;background-clip:text;color:transparent}
    .menu p{margin:0 0 4px;font-size:.72rem;line-height:1.45;color:#9eb5c6}
    .menu .btn-row{display:flex;flex-wrap:wrap;gap:10px;justify-content:center}
    .btn{--grad:linear-gradient(90deg,#22d3ee,#2563eb);background:var(--grad);color:#041019;border:none;font-size:.62rem;font-weight:600;letter-spacing:.8px;text-transform:uppercase;padding:12px 20px;border-radius:16px;display:inline-flex;align-items:center;gap:6px;cursor:pointer;position:relative;overflow:hidden;transition:.45s;box-shadow:0 6px 20px -8px rgba(34,211,238,.55),0 0 0 1px rgba(34,211,238,.4)}
    .btn.alt{--grad:linear-gradient(90deg,#ff8d5d,#ffcf4d);box-shadow:0 6px 20px -8px rgba(255,170,80,.55),0 0 0 1px rgba(255,200,140,.4)}
    .btn:hover{transform:translateY(-3px) scale(1.04)}
    .btn:active{transform:translateY(0) scale(.97)}
    .btn::after{content:"";position:absolute;inset:0;background:linear-gradient(120deg,rgba(255,255,255,.55),rgba(255,255,255,0) 60%);mix-blend-mode:overlay;opacity:0;transition:.55s}
    .btn:hover::after{opacity:.6}

    .toast{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);background:#0e1d2a;padding:10px 16px;border:1px solid #1c3344;border-radius:14px;font-size:.65rem;letter-spacing:.5px;display:flex;align-items:center;gap:8px;color:#b7ccd8;box-shadow:0 8px 26px -12px #000b;opacity:0;pointer-events:none;transition:.55s}
    .toast.show{opacity:1;transform:translate(-50%,0)}

    footer{padding:30px 20px 50px;text-align:center;font-size:.6rem;color:#6e8594;letter-spacing:.4px}

    /* === Magical UI Enhancements === */
    :root{
      --magic-accent:#8b5cf6; /* violet */
      --magic-accent2:#06b6d4; /* cyan */
      --magic-glow:0 0 12px -2px rgba(139,92,246,.9),0 0 34px -6px rgba(6,182,212,.65),0 0 4px 1px rgba(255,255,255,.08);
    }
    body{
      background:
        radial-gradient(circle at 20% 25%,rgba(139,92,246,.20),transparent 55%),
        radial-gradient(circle at 80% 70%,rgba(6,182,212,.18),transparent 60%),
        linear-gradient(140deg,#0b1322,#091525 55%,#06101a);
      animation:bgShift 18s linear infinite;
      background-size:140% 140%;
    }
    @keyframes bgShift{0%{background-position:0 0,0 0,0 0}50%{background-position:60% 40%,40% 60%,0 0}100%{background-position:0 0,0 0,0 0}}

    /* Scope header glow only when game playing */
    body.playing header h1{
      position:relative;
      text-shadow:0 0 6px rgba(139,92,246,.75),0 0 18px rgba(6,182,212,.55);
    }
    body.playing header h1:after{content:"";position:absolute;inset:0;mix-blend-mode:overlay;pointer-events:none;background:conic-gradient(from 0deg,rgba(255,255,255,.2),transparent 40%,rgba(255,255,255,.2) 60%,transparent 100%);animation:spinAura 8s linear infinite;filter:blur(6px);opacity:.55;}
    /* Restore static body background; remove global animation */
    body{background:radial-gradient(900px 600px at 12% 8%,#12273b,#060c14 70%)!important;animation:none!important;}
    /* New magic layer container (hidden until Start) */
    .magic-layer{position:absolute;inset:0;z-index:0;pointer-events:none;overflow:hidden;display:none;/* ...existing gradient ... */background:radial-gradient(circle at 20% 25%,rgba(139,92,246,.12),transparent 55%),radial-gradient(circle at 80% 70%,rgba(6,182,212,.12),transparent 60%),linear-gradient(140deg,#0b1322,#091525 55%,#06101a);background-size:140% 140%;animation:bgShift 18s linear infinite;} 
    .magic-layer.show{display:block;}
    canvas{position:relative;z-index:1;}
    /* Floating orbs container */
    .orb{position:absolute;width:18px;height:18px;border-radius:50%;
      background:radial-gradient(circle at 30% 30%,#ffffff,rgba(255,255,255,0) 70%);
      mix-blend-mode:screen;pointer-events:none;opacity:.75;filter:blur(.5px) drop-shadow(0 0 6px rgba(139,92,246,.85));
      animation:float 12s linear infinite;
    }
    .orb.orb-alt{filter:blur(.5px) drop-shadow(0 0 6px rgba(6,182,212,.85));}
    @keyframes float{0%{transform:translateY(0) translateX(0) scale(.7);opacity:.3}25%{opacity:.85}50%{transform:translateY(-60px) translateX(40px) scale(1)}75%{opacity:.6}100%{transform:translateY(0) translateX(0) scale(.7);opacity:.3}}

    canvas{box-shadow:0 0 0 1px rgba(139,92,246,.25),0 0 22px -10px rgba(139,92,246,.8),0 0 64px -14px rgba(6,182,212,.55);}    

    .hud span{background:linear-gradient(140deg,rgba(139,92,246,.35),rgba(6,182,212,.28));border:1px solid rgba(255,255,255,.25);box-shadow:var(--magic-glow);}    
    .crosshair:before,.crosshair:after{background:linear-gradient(90deg,#8b5cf6,#06b6d4);box-shadow:0 0 6px rgba(139,92,246,.9);} 
    .element-info{position:absolute;right:8px;bottom:8px;max-width:240px;font-size:.55rem;line-height:1.25;background:rgba(5,18,28,.72);border:1px solid rgba(255,255,255,.18);backdrop-filter:blur(6px) saturate(160%);padding:10px 12px;border-radius:12px;box-shadow:0 4px 14px -6px #000a;color:#d9ecf6;display:none;}
    .element-info h3{margin:0 0 4px;font-size:.75rem;letter-spacing:.5px;font-weight:600;color:#fff;text-shadow:0 0 4px #8b5cf6}
    .element-info table{width:100%;border-collapse:collapse;margin:4px 0 6px}
    .element-info td{padding:2px 0;vertical-align:top}
    .element-info td.key{color:#8dd4f9;padding-right:6px;white-space:nowrap}
    .element-info code{font-family:ui-monospace,monospace;font-size:.6rem;background:rgba(255,255,255,.08);padding:2px 4px;border-radius:6px;display:inline-block;margin-top:4px}
    .element-info .use{margin-top:6px;color:#b9d9e8}
    .element-info canvas{width:100%;height:auto;display:block;margin:4px 0 8px;image-rendering:crisp-edges}
    .element-info ul{margin:4px 0 6px 14px;padding:0}
    .element-info .facts{margin-top:6px;padding-top:6px;border-top:1px solid rgba(255,255,255,.08)}
  </style>
</head>
<body>
  <header>
    <h1>3D Maze – Lab Preview <sup style="font-size:.55em;font-weight:600;opacity:.8">v4</sup></h1>
    <nav>
      <a href="index.html" aria-label="Back to home">← Home</a>
      <a href="games.html#maze-3d&autostart&fullscreen" aria-label="Games Hub">Games Hub</a>
    </nav>
  </header>
  <main>
    <div class="game-shell" id="gameShell">
      <div id="magicLayer" class="magic-layer" aria-hidden="true"></div>
      <canvas id="mazeCanvas" width="960" height="540" aria-label="3D maze canvas"></canvas>
      
      <!-- Helmet HUD Top -->
      <div class="helmet-hud-top" id="helmetHudTop" hidden>
        <div class="compass">
          <div class="compass-rose">
            <div class="compass-directions">
              <div class="compass-n">N</div>
              <div class="compass-s">S</div>
              <div class="compass-e">E</div>
              <div class="compass-w">W</div>
            </div>
            <div class="compass-needle" id="compassNeedle"></div>
            <div class="hydrogen-pointer" id="hydrogenPointer"></div>
          </div>
          <div id="compassInfo">Sector H-1</div>
        </div>
      </div>
      
      <!-- Helmet HUD Bottom -->
      <div class="helmet-hud-bottom" id="helmetHudBottom" hidden>
        <div class="status-info">
          <span id="hudPerf">FPS: –</span>
          <span id="hudPos">X:0 Y:0</span>
          <span id="hudInfo">HP:100 Ammo:∞</span>
          <span id="hudXP">XP:0</span>
        </div>
        <div class="minimap-container">
          <canvas id="minimapCanvas"></canvas>
        </div>
      </div>
      
      <div class="hud" id="hud" hidden>
        <span id="hudPerf">FPS: –</span>
        <span id="hudPos">X:0 Y:0</span>
        <span id="hudInfo">HP:100 Ammo:∞</span>
        <span id="hudXP">XP:0</span>
      </div>
      <div id="elementInfoPanel" class="element-info" aria-live="polite" hidden></div>
      <div class="crosshair" id="crosshair" hidden></div>
      <div class="overlay" id="startOverlay" role="dialog" aria-modal="true">
        <div class="menu">
          <h2>Enter The Scientific Lab</h2>
          <p>Lightweight ray‑cast prototype. Explore with fluid mouse look & WASD. Space to jump (cosmetic), click to fire particles.</p>
          <p style="opacity:.8">Performance friendly: Simplified floor & dynamic resolution scaler. No enemies in this preview build.</p>
          <div class="btn-row">
            <button class="btn" id="btnStart">Start</button>
            <button class="btn alt" id="btnFS">Fullscreen</button>
            <button class="btn" id="btnInvert">Invert Y: On</button>
          </div>
        </div>
      </div>
      <div class="toast" id="toast" role="status" aria-live="polite"></div>
    </div>
  </main>
  <footer>Prototype engine (c) Lab Maze Preview · Auto‑evolves with site game improvements.</footer>

  <noscript><p style="text-align:center;padding:40px 20px;color:#ff6b6b">Enable JavaScript to run the 3D Maze.</p></noscript>

  <script>
  (()=>{
    const canvas=document.getElementById('mazeCanvas');
    const ctx=canvas.getContext('2d');
    const minimapCanvas=document.getElementById('minimapCanvas');
    const minimapCtx=minimapCanvas.getContext('2d');
    
    // Helmet HUD elements
    const helmetHudTop=document.getElementById('helmetHudTop');
    const helmetHudBottom=document.getElementById('helmetHudBottom');
    const compassNeedle=document.getElementById('compassNeedle');
    const hydrogenPointer=document.getElementById('hydrogenPointer');
    const compassInfo=document.getElementById('compassInfo');
    
    // Set minimap size to fit in helmet HUD (smaller)
    minimapCanvas.width = 80;
    minimapCanvas.height = 80;
    minimapCanvas.style.width = '100%';
    minimapCanvas.style.height = '100%';
    minimapCtx.imageSmoothingEnabled = false;

    const hudPerf=document.getElementById('hudPerf');
    const hudPos=document.getElementById('hudPos');
    const hudInfo=document.getElementById('hudInfo');
    const hud=document.getElementById('hud');
    const crosshair=document.getElementById('crosshair');
    const overlay=document.getElementById('startOverlay');
    const toastEl=document.getElementById('toast');
    const btnStart=document.getElementById('btnStart');
    const btnFS=document.getElementById('btnFS');
    const btnInvert=document.getElementById('btnInvert');
    const elementInfoPanel=document.getElementById('elementInfoPanel');
    const hudXP=document.getElementById('hudXP');
    const magicLayer=document.getElementById('magicLayer'); // FIX: was undefined causing black screen

    // --- Ensure jump helper exists (was removed during refactor) ---
    function jump(){ if(!state.jumping && state.jumpZ===0){ state.jumping=true; state.vz=state.jumpImpulse; } }

    // --- Hydrogen detailed data panel (re-added after map refactor) ---
    const hydrogenData = {
      name:'Hydrogen', symbol:'H', number:1, atomicMass:'1.008', group:'1 (non‑metal)', period:1,
      category:'Diatomic nonmetal', electronConfig:'1s^1', meltingPoint:'14.01 K', boilingPoint:'20.28 K',
      electronegativity:'2.20 (Pauling)', density:'0.08988 g/L (0 °C, 1 atm)', appearance:'Colorless gas',
      abundanceUniverse:'~75% of normal (baryonic) matter by mass', ionizationEnergy:'13.598 eV',
      isotopes:'1H (protium) 99.98%, 2H (deuterium) ~0.02%, 3H (tritium) trace (radioactive)',
      discovery:'Known since prehistory (distinctly described 1766 – Cavendish)',
      recentResearch:'High‑pressure phases & pursuit of metallic hydrogen; potential superconductivity remains under active investigation.',
      uses:['Ammonia synthesis (Haber‑Bosch)','Petroleum hydrocracking','Fuel cells (clean power)'],
      funFacts:[
        'Lightest & most abundant element',
        'Forms stars via nuclear fusion (proton–proton chain)',
        'Liquid hydrogen used as rocket propellant (with liquid oxygen)',
        'Deuterium used in heavy water reactors',
        'Potential clean energy carrier in green hydrogen economy'
      ],
      efficiencyExample:{ title:'Efficient Application: PEM Fuel Cell', desc:'Hydrogen + oxygen → electricity + water (~60% electrical efficiency). Waste heat can raise total efficiency in CHP.', reaction:'2 H₂ + O₂ → 2 H₂O + energy' }
    };
    // 3D mini-orbit renderer state
    let h3dCanvas=null,h3dCtx=null,h3dAngle=0;
    function ensureHydrogen3DCanvas(){
      if(!elementInfoPanel) return; if(h3dCanvas && h3dCanvas.isConnected) return;
      h3dCanvas=document.createElement('canvas'); h3dCanvas.width=180; h3dCanvas.height=180; h3dCtx=h3dCanvas.getContext('2d');
      const spot=elementInfoPanel.querySelector('.h3d'); if(spot){ spot.innerHTML=''; spot.appendChild(h3dCanvas); }
    }
    function renderHydrogen3D(){ if(!h3dCtx || elementInfoPanel.hidden) return; const ctx3=h3dCtx; const w=h3dCanvas.width, h=h3dCanvas.height; ctx3.clearRect(0,0,w,h);
      const cx=w/2, cy=h/2+4; const nucleusR=22; // nucleus
      // soft glow
      const g=ctx3.createRadialGradient(cx,cy,4,cx,cy,nucleusR*2.4); g.addColorStop(0,'rgba(180,230,255,0.55)'); g.addColorStop(1,'rgba(40,80,120,0)'); ctx3.fillStyle=g; ctx3.beginPath(); ctx3.arc(cx,cy,nucleusR*2.2,0,Math.PI*2); ctx3.fill();
      // nucleus core
      const g2=ctx3.createRadialGradient(cx-nucleusR*0.4,cy-nucleusR*0.4,2,cx,cy,nucleusR); g2.addColorStop(0,'#ffffff'); g2.addColorStop(1,'#8cc9ff'); ctx3.fillStyle=g2; ctx3.beginPath(); ctx3.arc(cx,cy,nucleusR,0,Math.PI*2); ctx3.fill();
      // orbit (tilted ellipse)
      h3dAngle += 0.02; const tilt=0.55; const orbitR=60; ctx3.save(); ctx3.translate(cx,cy); ctx3.rotate(0.35); ctx3.scale(1, tilt); ctx3.strokeStyle='rgba(140,210,255,0.55)'; ctx3.lineWidth=2; ctx3.beginPath(); ctx3.arc(0,0,orbitR,0,Math.PI*2); ctx3.stroke(); ctx3.restore();
      // electron 3D-ish position
      const ex = Math.cos(h3dAngle)*orbitR; const ez = Math.sin(h3dAngle); const ey = Math.sin(h3dAngle)*orbitR*tilt; // simple
      const depth = 0.5 + (ez*0.5); const eScreenX = cx + ex*Math.cos(0.35) - ey*Math.sin(0.35)*0; const eScreenY = cy + ey + ez*6; const eR=8 + depth*3;
      // trail
      ctx3.globalAlpha=0.35; ctx3.strokeStyle='rgba(150,230,255,0.4)'; ctx3.beginPath(); for(let a=0;a<Math.PI*2;a+=Math.PI/40){ const tx=Math.cos(a)*orbitR; const ty=Math.sin(a)*orbitR*tilt; ctx3.lineTo(cx+tx*Math.cos(0.35), cy+ty); } ctx3.stroke(); ctx3.globalAlpha=1;
      // electron sphere
      const eg=ctx3.createRadialGradient(eScreenX-eR*0.4, eScreenY-eR*0.4, 2, eScreenX, eScreenY, eR); eg.addColorStop(0,'#ffffff'); eg.addColorStop(1,'#5cc9ff'); ctx3.fillStyle=eg; ctx3.beginPath(); ctx3.arc(eScreenX,eScreenY,eR,0,Math.PI*2); ctx3.fill();
    }

    // --- Hydrogen fountain with orbiting electron ---
    const hydrogenFountain = {
      x: 0, y: 0, // Will be set to hydrogen station position
      electron: {
        angle: 0,
        radius: 0.3,
        height: 0.2,
        speed: 2.0,
        randomOffset: { x: 0, y: 0, z: 0 },
        lastRandomTime: 0
      },
      particles: []
    };
    
    function updateHydrogenFountain(dt) {
      if (!stations[0]) return;
      
      hydrogenFountain.x = stations[0].x;
      hydrogenFountain.y = stations[0].y;
      
      // Update electron orbit with random positions
      const electron = hydrogenFountain.electron;
      electron.angle += electron.speed * dt;
      
      // Add random position changes every 2 seconds
      if (performance.now() - electron.lastRandomTime > 2000) {
        electron.randomOffset.x = (Math.random() - 0.5) * 0.2;
        electron.randomOffset.y = (Math.random() - 0.5) * 0.2;
        electron.randomOffset.z = (Math.random() - 0.5) * 0.1;
        electron.lastRandomTime = performance.now();
      }
      
      // Calculate electron position
      electron.x = hydrogenFountain.x + Math.cos(electron.angle) * electron.radius + electron.randomOffset.x;
      electron.y = hydrogenFountain.y + Math.sin(electron.angle) * electron.radius + electron.randomOffset.y;
      electron.z = electron.height + Math.sin(electron.angle * 3) * 0.1 + electron.randomOffset.z;
      
      // Add fountain particles
      if (Math.random() < 0.3) {
        hydrogenFountain.particles.push({
          x: hydrogenFountain.x + (Math.random() - 0.5) * 0.1,
          y: hydrogenFountain.y + (Math.random() - 0.5) * 0.1,
          z: 0,
          vz: 1 + Math.random() * 0.5,
          life: 2 + Math.random(),
          maxLife: 2 + Math.random(),
          color: `hsl(${200 + Math.random() * 60}, 80%, ${50 + Math.random() * 30}%)`
        });
      }
      
      // Update fountain particles
      for (let i = hydrogenFountain.particles.length - 1; i >= 0; i--) {
        const p = hydrogenFountain.particles[i];
        p.z += p.vz * dt;
        p.vz -= 2 * dt; // gravity
        p.life -= dt;
        
        if (p.life <= 0 || p.z < 0) {
          hydrogenFountain.particles.splice(i, 1);
        }
      }
    }
    
    function renderHydrogenFountain() {
      const dx = hydrogenFountain.x - state.px;
      const dy = hydrogenFountain.y - state.py;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 8) return; // Only render if close enough
      
      const dirX = Math.cos(state.dir * Math.PI/180);
      const dirY = Math.sin(state.dir * Math.PI/180);
      const planeFov = 0.66;
      const w = canvas.width, h = canvas.height;
      const horizon = h/2 + state.pitch*180 - state.jumpZ*26;
      
      // Render nucleus (core)
      const nucleusAngle = Math.atan2(dy, dx) - state.dir * Math.PI/180;
      const nucleusScreenX = Math.tan(nucleusAngle) * (w / (2 * planeFov)) + w/2;
      const nucleusSize = Math.min(30, h / (dist * 2));
      const nucleusScreenY = horizon - nucleusSize/2;
      
      // Nucleus glow
      const gradient = ctx.createRadialGradient(nucleusScreenX, nucleusScreenY, 0, nucleusScreenX, nucleusScreenY, nucleusSize);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
      gradient.addColorStop(0.5, 'rgba(139, 92, 246, 0.7)');
      gradient.addColorStop(1, 'rgba(139, 92, 246, 0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(nucleusScreenX, nucleusScreenY, nucleusSize, 0, Math.PI * 2);
      ctx.fill();
      
      // Render orbiting electron
      const electron = hydrogenFountain.electron;
      const eDx = electron.x - state.px;
      const eDy = electron.y - state.py;
      const eDist = Math.sqrt(eDx * eDx + eDy * eDy);
      const eAngle = Math.atan2(eDy, eDx) - state.dir * Math.PI/180;
      const eScreenX = Math.tan(eAngle) * (w / (2 * planeFov)) + w/2;
      const eSize = Math.min(12, h / (eDist * 3));
      const eScreenY = horizon - eSize/2 - electron.z * 50;
      
      // Electron trail
      ctx.strokeStyle = 'rgba(6, 182, 212, 0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let a = 0; a < Math.PI * 2; a += Math.PI / 20) {
        const trailX = hydrogenFountain.x + Math.cos(a) * electron.radius - state.px;
        const trailY = hydrogenFountain.y + Math.sin(a) * electron.radius - state.py;
        const trailAngle = Math.atan2(trailY, trailX) - state.dir * Math.PI/180;
        const trailScreenX = Math.tan(trailAngle) * (w / (2 * planeFov)) + w/2;
        if (a === 0) ctx.moveTo(trailScreenX, horizon);
        else ctx.lineTo(trailScreenX, horizon);
      }
      ctx.stroke();
      
      // Electron
      ctx.fillStyle = 'rgba(6, 182, 212, 0.9)';
      ctx.beginPath();
      ctx.arc(eScreenX, eScreenY, eSize, 0, Math.PI * 2);
      ctx.fill();
      
      // Render fountain particles
      for (const p of hydrogenFountain.particles) {
        const pDx = p.x - state.px;
        const pDy = p.y - state.py;
        const pDist = Math.sqrt(pDx * pDx + pDy * pDy);
        const pAngle = Math.atan2(pDy, pDx) - state.dir * Math.PI/180;
        const pScreenX = Math.tan(pAngle) * (w / (2 * planeFov)) + w/2;
        const pSize = Math.min(6, h / (pDist * 4));
        const pScreenY = horizon - pSize/2 - p.z * 30;
        
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = p.color.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
        ctx.beginPath();
        ctx.arc(pScreenX, pScreenY, pSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function showHydrogenPanel(dist){
      if(!elementInfoPanel) return; const d=hydrogenData; if(!elementInfoPanel._hydroBuilt){
        const usesList=d.uses.map(u=>`<li>${u}</li>`).join('');
        const facts=d.funFacts.map(f=>`<li>${f}</li>`).join('');
        elementInfoPanel.innerHTML = `
          <h3>${d.name} – ${d.symbol}</h3>
          <div class='h3d' aria-hidden='true'></div>
          <table><tbody>
            <tr><td class='key'>Atomic #</td><td>${d.number}</td></tr>
            <tr><td class='key'>Mass</td><td>${d.atomicMass} u</td></tr>
            <tr><td class='key'>Group</td><td>${d.group}</td></tr>
            <tr><td class='key'>Period</td><td>${d.period}</td></tr>
            <tr><td class='key'>Category</td><td>${d.category}</td></tr>
            <tr><td class='key'>e⁻ Config</td><td>${d.electronConfig}</td></tr>
            <tr><td class='key'>Ionization</td><td>${d.ionizationEnergy}</td></tr>
            <tr><td class='key'>Melt</td><td>${d.meltingPoint}</td></tr>
            <tr><td class='key'>Boil</td><td>${d.boilingPoint}</td></tr>
            <tr><td class='key'>Density</td><td>${d.density}</td></tr>
            <tr><td class='key'>Abundance</td><td>${d.abundanceUniverse}</td></tr>
            <tr><td class='key'>Isotopes</td><td>${d.isotopes}</td></tr>
          </tbody></table>
          <div class='use'><strong>Uses</strong><ul>${usesList}</ul></div>
          <div class='use'><strong>${d.efficiencyExample.title}</strong><br>${d.efficiencyExample.desc}<br><code>${d.efficiencyExample.reaction}</code></div>
          <div class='facts'><strong>Fun Facts</strong><ul>${facts}</ul></div>
          <div class='facts'><strong>Research</strong><br>${d.recentResearch}</div>
          <div style='margin-top:4px;opacity:.7'>Room dist: <span id='hydroDist'>${dist.toFixed(2)}</span></div>`;
        elementInfoPanel._hydroBuilt=true; ensureHydrogen3DCanvas();
      } else {
        const dd=document.getElementById('hydroDist'); if(dd) dd.textContent=dist.toFixed(2);
      }
      elementInfoPanel.style.display='block'; elementInfoPanel.hidden=false;
    }
    function hideHydrogenPanel(){ if(!elementInfoPanel) return; elementInfoPanel.style.display='none'; elementInfoPanel.hidden=true; }

    function toast(msg,ms=2600){toastEl.textContent=msg;toastEl.classList.add('show');clearTimeout(toastEl._t);toastEl._t=setTimeout(()=>toastEl.classList.remove('show'),ms)}

    // --- Update compass and hydrogen pointer ---
    function updateCompass() {
      if (!compassNeedle || !hydrogenPointer || !stations[0]) return;
      
      // Update compass needle to point north
      const needleRotation = -state.dir; // Opposite of player direction
      compassNeedle.style.transform = `rotate(${needleRotation}deg)`;
      
      // Update hydrogen pointer
      const hx = stations[0].x;
      const hy = stations[0].y;
      const dx = hx - state.px;
      const dy = hy - state.py;
      const hydrogenAngle = Math.atan2(dy, dx) * 180 / Math.PI - state.dir;
      const hydrogenDist = Math.sqrt(dx * dx + dy * dy);
      
      hydrogenPointer.style.transform = `rotate(${hydrogenAngle}deg) translateY(-25px)`;
      hydrogenPointer.style.opacity = hydrogenDist < 10 ? '1' : '0.5';
      
      // Update compass info with nearby elements
      const nearbyElements = stations.filter(s => {
        const d = Math.sqrt((s.x - state.px) ** 2 + (s.y - state.py) ** 2);
        return d < 5;
      }).slice(0, 3);
      
      if (compassInfo) {
        let info = `Sector H-${Math.floor(state.px / 5)}-${Math.floor(state.py / 5)}`;
        if (nearbyElements.length > 0) {
          info += ` | Nearby: ${nearbyElements.map(e => e.sym).join(', ')}`;
        }
        compassInfo.textContent = info;
      }
    }

    // === Laboratory Room Grid Generation (Each Element = One Room) ===
    const GRID=11;              // 11x11 => 121 potential rooms (>=118 elements)
    const ROOM_INNER=5;         // interior walkable square per room
    const width = GRID*ROOM_INNER + (GRID+1); // walls between rooms + border walls
    const height = width;       // square layout
    let mapArr = Array.from({length:height}, ()=> Array(width).fill('#'));

    const elementSymbols = "H He Li Be B C N O F Ne Na Mg Al Si P S Cl Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag Cd In Sn Sb Te I Xe Cs Ba La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm Yb Lu Hf Ta W Re Os Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No Lr Rf Db Sg Bh Hs Mt Ds Rg Cn Nh Fl Mc Lv Ts Og";
    const elements=[]; elementSymbols.split(/\s+/).forEach((sym,i)=> elements.push({num:i+1,sym}));
    const stations=[];

    for(let gy=0, idx=0; gy<GRID; gy++){
      for(let gx=0; gx<GRID; gx++){
        if(idx >= elements.length) break; // unused extra rooms remain solid
        const x0 = 1 + gx*(ROOM_INNER+1); // interior top-left (skip wall)
        const y0 = 1 + gy*(ROOM_INNER+1);
        // carve interior
        for(let yy=0; yy<ROOM_INNER; yy++){
          for(let xx=0; xx<ROOM_INNER; xx++) mapArr[y0+yy][x0+xx]='.';
        }
        // station at center
        const elem = elements[idx++];
        stations.push({ x: x0 + ROOM_INNER/2, y: y0 + ROOM_INNER/2, ...elem });
        // horizontal tunnel to right room (carve door in shared wall)
        if(gx < GRID-1){
          const doorX = x0 + ROOM_INNER; // wall column
          const doorY = y0 + Math.floor(ROOM_INNER/2);
          mapArr[doorY][doorX]='.';
        }
        // vertical tunnel downward
        if(gy < GRID-1){
          const doorY = y0 + ROOM_INNER; // wall row
          const doorX = x0 + Math.floor(ROOM_INNER/2);
            mapArr[doorY][doorX]='.';
        }
      }
    }
    const map = mapArr.map(r=>r.join(''));
    const MAP_W = width, MAP_H = height;
    const hydrogenStation = stations[0];

    const state={
      px: hydrogenStation ? hydrogenStation.x + 1.1 : 3.5,
      py: hydrogenStation ? hydrogenStation.y : 3.5,
      dir: 0, pitch:0, jumpZ:0, jumping:false,
      moveSpeed:3.4, rotSpeed:2.4, strafeSpeed:3.2,
      invY:false, keys:{},
      lastTime: performance.now(),
      fps:0, frames:0, fpsTime:0,
      pixelStep:1,
      shootParticles:[],
      vz:0, gravity:14, jumpImpulse:6,
      xp:0
    };
    // Ensure canvas can receive focus (for overlay focus shift)
    canvas.setAttribute('tabindex','-1');
    // Core loop state (moved BEFORE startGame to avoid TDZ access)
    let running=false, rafId=null;
    // Global error trap to surface silent failures
    window.onerror = (m,src,line,col,err)=>{ console.error('[MazeError]',m,src,line,col,err); toast('Error: '+m); return false; };

    // === (Re)Add high-DPI resize helper if missing ===
    if(typeof window.resizeForDPR !== 'function'){
      window.resizeForDPR = function resizeForDPR(){
        const scale=Math.min(window.devicePixelRatio||1,2);
        if(document.fullscreenElement || document.body.classList.contains('playing')){
          const w=window.innerWidth, h=window.innerHeight;
          canvas.width=w*scale; canvas.height=h*scale;
          canvas.style.width=w+'px'; canvas.style.height=h+'px';
        } else {
          canvas.width=960*scale; canvas.height=540*scale;
          canvas.style.width='960px'; canvas.style.height='540px';
        }
        ctx.imageSmoothingEnabled=false;
      };
      window.addEventListener('resize', resizeForDPR);
      resizeForDPR();
      console.log('[init] resizeForDPR restored, canvas=', canvas.width, canvas.height);
    }
    // --- Main game logic ---
    function update(){
      const now=performance.now();
      const dt=(now-state.lastTime)/1000; state.lastTime=now;
      state.frames++; state.fpsTime += dt; // accumulate real elapsed seconds
      if(state.fpsTime >= 1){ hudPerf.textContent='FPS: '+state.frames; // adaptive pixelStep: if FPS low -> increase pixelStep, if high -> decrease
        const measured = state.frames; state.frames=0; state.fpsTime=0;
        // simple moving decision: increase if <45, decrease if >55
        if(measured < 42 && state.pixelStep < 3){ state.pixelStep++; resizeForDPR(); toast('Auto: lower res'); }
        else if(measured > 55 && state.pixelStep > 1){ state.pixelStep--; resizeForDPR(); toast('Auto: higher res'); }
      }
      // --- Movement ---
      const moveDir=state.keys.w ? 1 : state.keys.s ? -1 : 0;
      const strafeDir=state.keys.d ? 1 : state.keys.a ? -1 : 0;
      const speed=state.jumping ? state.moveSpeed*0.6 : state.moveSpeed;
      let newPx = state.px, newPy = state.py;
      if(moveDir) {
        const moveX = Math.cos(state.dir * Math.PI/180) * moveDir * speed * dt;
        const moveY = Math.sin(state.dir * Math.PI/180) * moveDir * speed * dt;
        newPx += moveX;
        newPy += moveY;
      }
      if(strafeDir) {
        const strafeX = Math.cos((state.dir + 90) * Math.PI/180) * strafeDir * speed * dt;
        const strafeY = Math.sin((state.dir + 90) * Math.PI/180) * strafeDir * speed * dt;
        newPx += strafeX;
        newPy += strafeY;
      }
      // Check bounds and walls
      if(newPx >= 1 && newPx < MAP_W-1 && newPy >= 1 && newPy < MAP_H-1){
        const tile = map[Math.floor(newPy)]?.[Math.floor(newPx)];
        if(tile !== '#'){
          state.px = newPx;
          state.py = newPy;
        }
      }
      // --- View angle ---
      if(state.keys.arrowleft) state.dir -= state.rotSpeed * dt;
      else if(state.keys.arrowright) state.dir += state.rotSpeed * dt;
      // Clamp pitch (up/down angle)
      if(state.keys.arrowup) state.pitch -= state.rotSpeed * 0.8 * dt;
      else if(state.keys.arrowdown) state.pitch += state.rotSpeed * 0.8 * dt;
      if(state.pitch < -89) state.pitch=-89;
      else if(state.pitch > 89) state.pitch=89;
      // --- Jumping ---
      if(state.keys.space) jump();
      // --- Shooting (debug: toggle XP) ---
      if(state.keys.enter) { state.xp += 10; toast('Gained 10 XP!'); }
      // --- Update HUD ---
      if(hudInfo){
        const ammo=state.shootParticles.length;
        hudInfo.textContent=`HP:100 Ammo:${ammo===0?'∞':ammo} XP:${state.xp}`;
      }
      
      // --- Update compass and hydrogen fountain ---
      updateCompass();
      updateHydrogenFountain(dt);
      // --- Particle update (simple gravity + fade out) ---
      const gravity=14, drag=.98;
      for(let i=state.shootParticles.length-1;i>=0;i--){
        const p=state.shootParticles[i];
        p.z += p.vz * dt; // vertical speed
        p.vz -= gravity * dt; // apply gravity
        p.x += Math.sin(p.angle) * 8 * dt; // horizontal drift
        p.y += Math.cos(p.angle) * 8 * dt;
        p.life -= dt;
        if(p.life <= 0) { state.shootParticles.splice(i,1); continue; }
        const f=1 - p.life * 0.7;
        ctx.fillStyle=`rgba(255,255,255,${f})`;
        ctx.strokeStyle=`rgba(255,255,255,${f})`;
        ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(p.x-3,p.y-3);
        ctx.lineTo(p.x+3,p.y+3);
        ctx.moveTo(p.x+3,p.y-3);
        ctx.lineTo(p.x-3,p.y+3);
        ctx.stroke();
      }
      // --- Room transition (debug: instant TP) ---
      if(state.keys.t){
        const roomIdx = Math.floor(Math.random() * stations.length);
        const dest = stations[roomIdx];
        if(dest){
          state.px = dest.x + 0.5;
          state.py = dest.y + 0.5;
          toast('Teleported to room '+dest.sym);
        }
      }
      // --- Render ---
      render();
    }

    function render(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const w=canvas.width, h=canvas.height;
      // Sky and floor gradients
      const horizon = h/2 + state.pitch*180 - state.jumpZ*26;
      const sky=ctx.createLinearGradient(0,0,0,Math.max(0,horizon)); sky.addColorStop(0,'#0d1f30'); sky.addColorStop(1,'#0a2638'); ctx.fillStyle=sky; ctx.fillRect(0,0,w,Math.max(0,horizon));
      if(horizon < h){ const fg=ctx.createLinearGradient(0,horizon,0,h); fg.addColorStop(0,'#0e2028'); fg.addColorStop(1,'#09151d'); ctx.fillStyle=fg; ctx.fillRect(0,horizon,w,h-horizon); }

      // Raycaster
      const dirX = Math.cos(state.dir * Math.PI/180), dirY = Math.sin(state.dir * Math.PI/180);
      const planeFov = 0.66; // FOV
      const planeX = -dirY * planeFov, planeY = dirX * planeFov;
      const cols = Math.floor(w / state.pixelStep);
      for(let c = 0; c < cols; c++){
        const cameraX = (2 * c / cols) - 1;
        const rayDirX = dirX + planeX * cameraX;
        const rayDirY = dirY + planeY * cameraX;
        let mapX = Math.floor(state.px), mapY = Math.floor(state.py);
        const deltaDistX = rayDirX === 0 ? 1e30 : Math.abs(1 / rayDirX);
        const deltaDistY = rayDirY === 0 ? 1e30 : Math.abs(1 / rayDirY);
        let stepX, stepY, sideDistX, sideDistY;
        if(rayDirX < 0){ stepX = -1; sideDistX = (state.px - mapX) * deltaDistX; } else { stepX = 1; sideDistX = (mapX + 1.0 - state.px) * deltaDistX; }
        if(rayDirY < 0){ stepY = -1; sideDistY = (state.py - mapY) * deltaDistY; } else { stepY = 1; sideDistY = (mapY + 1.0 - state.py) * deltaDistY; }
        let hit = 0, side = 0;
        while(hit === 0){
          if(sideDistX < sideDistY){ sideDistX += deltaDistX; mapX += stepX; side = 0; } else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
          const tile = map[mapY]?.[mapX];
          if(tile === '#' || !tile){ hit = 1; }
        }
        let perpWallDist = side === 0 ? (mapX - state.px + (1 - stepX)/2) / rayDirX : (mapY - state.py + (1 - stepY)/2) / rayDirY;
        if(perpWallDist < 0.0002) perpWallDist = 0.0002;
        const lineHeight = Math.min(h, Math.floor(h / perpWallDist));
        const drawStart = Math.floor(horizon - lineHeight/2);
        const drawEnd = Math.floor(horizon + lineHeight/2);
        const color = wallColor(mapX, mapY, perpWallDist, side);
        ctx.fillStyle = color;
        ctx.fillRect(c * state.pixelStep, drawStart, state.pixelStep, drawEnd - drawStart);
      }

      // Draw particles as billboards
      for(const p of state.shootParticles){
        const dx = p.x - state.px, dy = p.y - state.py;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if(dist < 0.1) continue;
        const angle = Math.atan2(dy, dx) - state.dir * Math.PI/180;
        const screenX = Math.tan(angle) * (w / (2 * planeFov)) + w/2;
        const screenSize = Math.min(20, h / dist);
        const screenY = horizon - screenSize/2;
        ctx.fillStyle = `rgba(255,255,255,${p.life})`;
        ctx.fillRect(screenX - screenSize/2, screenY, screenSize, screenSize);
      }

      // Draw stations as sprites
      for(const stat of stations){
        const dx = stat.x - state.px, dy = stat.y - state.py;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if(dist < 0.1) continue;
        const angle = Math.atan2(dy, dx) - state.dir * Math.PI/180;
        const screenX = Math.tan(angle) * (w / (2 * planeFov)) + w/2;
        const screenSize = Math.min(10, h / dist);
        const screenY = horizon - screenSize/2;
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(screenX - screenSize/2, screenY, screenSize, screenSize);
      }

      // Draw hydrogen fountain
      renderHydrogenFountain();

      // Render 3D hydrogen mini-view in info panel (if present)
      renderHydrogen3D();

      // Auto-show element panel for nearest station when within 4 units
      if(stations && stations.length){
        let nearest = null; let nd = Infinity;
        for(const s of stations){ const dx = s.x - state.px, dy = s.y - state.py; const d = Math.sqrt(dx*dx + dy*dy); if(d < nd){ nd = d; nearest = s; } }
        if(nearest && nd < 4){ showHydrogenPanel(nd); } else { hideHydrogenPanel(); }
      }

      // Draw minimap
      renderMinimap();

      if(hudPos){ hudPos.textContent=`X:${state.px.toFixed(2)} Y:${state.py.toFixed(2)}`; }
    }

    function renderMinimap(){
      minimapCtx.clearRect(0,0,minimapCanvas.width,minimapCanvas.height);
      const scale = minimapCanvas.width / MAP_W;
      minimapCtx.fillStyle = '#0d1824';
      minimapCtx.fillRect(0,0,minimapCanvas.width,minimapCanvas.height);
      minimapCtx.fillStyle = '#163044';
      for(let y=0;y<MAP_H;y++){
        for(let x=0;x<MAP_W;x++){
          if(map[y][x] === '.') minimapCtx.fillRect(x*scale, y*scale, scale, scale);
        }
      }
      // Draw player
      minimapCtx.fillStyle = '#ff0000';
      minimapCtx.fillRect(state.px*scale - 2, state.py*scale - 2, 4, 4);
      // Draw stations
      minimapCtx.fillStyle = '#22d3ee';
      for(const stat of stations){
        minimapCtx.fillRect(stat.x*scale - 1, stat.y*scale - 1, 2, 2);
      }
    }

    // --- Input handling ---
    function onKeyDown(e){
      if(e.repeat) return;
      const key=e.key.toLowerCase();
      if(key==='f11') { e.preventDefault(); toggleMenu(); return; }
      if(key==='escape') { if(running) stopGame(); else showOverlay(); return; }
      if(running){
        if(key==='w') state.keys.w=true;
        else if(key==='s') state.keys.s=true;
        else if(key==='a') state.keys.a=true;
        else if(key==='d') state.keys.d=true;
        else if(key==='arrowup') state.keys.arrowup=true;
        else if(key==='arrowdown') state.keys.arrowdown=true;
        else if(key==='arrowleft') state.keys.arrowleft=true;
        else if(key==='arrowright') state.keys.arrowright=true;
        else if(key===' ') state.keys.space=true;
        else if(key==='t') state.keys.t=true;
        else if(key==='enter') state.keys.enter=true;
      } else {
        if(key==='arrowup') state.keys.arrowup=true;
        else if(key==='arrowdown') state.keys.arrowdown=true;
        else if(key==='arrowleft') state.keys.arrowleft=true;
        else if(key==='arrowright') state.keys.arrowright=true;
      }
    }
    function onKeyUp(e){
      const key=e.key.toLowerCase();
      if(running){
        if(key==='w') state.keys.w=false;
        else if(key==='s') state.keys.s=false;
        else if(key==='a') state.keys.a=false;
        else if(key==='d') state.keys.d=false;
        else if(key==='arrowup') state.keys.arrowup=false;
        else if(key==='arrowdown') state.keys.arrowdown=false;
        else if(key==='arrowleft') state.keys.arrowleft=false;
        else if(key==='arrowright') state.keys.arrowright=false;
        else if(key===' ') state.keys.space=false;
        else if(key==='t') state.keys.t=false;
        else if(key==='enter') state.keys.enter=false;
      }
    }
    function onMouseMove(e){
      if(!running) return;
      if(e.movementX !== undefined && e.movementY !== undefined){
        // Pointer lock movement
        const sensitivity = 0.08;
        const yMult = state.invY ? 1 : -1; // Inverted: forward mouse = look up
        state.dir += e.movementX * sensitivity; // X-axis not affected by invert
        state.pitch += e.movementY * sensitivity * yMult; // Y-axis inverted by default
        state.pitch = Math.max(-89, Math.min(89, state.pitch));
      }
    }
    function onMouseDown(e){
      if(!running) return;
      if(e.button===0){
        // Shoot particle
        state.shootParticles.push({
          x: state.px,
          y: state.py,
          z: state.jumpZ + 0.5,
          vz: 2,
          angle: state.dir * Math.PI/180,
          life: 1.5
        });
        toast('Pew!', 800);
      }
    }
    function onMouseUp(e){
      if(e.button===0) state.keys.enter=false;
    }

    // Add event listeners
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mouseup', onMouseUp);

    // --- Pointer lock helpers ---
    function lockPointer(){
      if(document.body.classList.contains('playing')){
        canvas.requestPointerLock?.();
        document.body.requestPointerLock?.();
      }
    }
    function unlockPointer(){
      document.exitPointerLock?.();
    }

    // --- Overlay focus fix (ensure canvas is focusable) ---
    overlay.addEventListener('focusin',()=>{
      setTimeout(()=>{ canvas.focus(); },50);
    });

    // --- Game loop ---
    function loop(){
      if(!running) return;
      update();
      rafId=requestAnimationFrame(loop);
    }

    function hideOverlayImmediate(){
      // Prevent aria-hidden focus conflict: move focus to canvas/body first
      if(overlay.contains(document.activeElement)){
        try { canvas.focus(); } catch(e) {}
        try { document.activeElement && document.activeElement.blur && document.activeElement.blur(); } catch(e){}
      }
      overlay.classList.add('hidden-force');
      overlay.setAttribute('aria-hidden','true');
      overlay.removeAttribute('aria-modal');
    }
    function showOverlay(){
      overlay.classList.remove('hidden-force');
      overlay.removeAttribute('aria-hidden');
      overlay.setAttribute('aria-modal','true');
    }
    async function startGame(){
      console.log('[startGame] invoked. running=',running);
      if(running) return;
      hideOverlayImmediate();
      document.body.classList.add('playing');
      magicLayer.classList.add('show'); magicLayer.removeAttribute('aria-hidden'); spawnOrbs();
      
      // Show helmet HUD instead of old HUD
      helmetHudTop.hidden=false; helmetHudBottom.hidden=false; crosshair.hidden=false; 
      hud.hidden=true; // Hide old HUD
      
      running=true; state.lastTime=performance.now(); state.fpsTime=0; state.frames=0; 
      toast('WASD • Mouse look • ESC pause • Helmet HUD active');
      // request pointer lock synchronously (gesture chain) then enter fullscreen
      try { canvas.requestPointerLock && canvas.requestPointerLock(); } catch(e){}
      try { await enterFullscreen(); } catch(e) { console.warn('Fullscreen denied',e); }
      resizeForDPR();
      render(); console.log('[first-frame] rendered OK, canvas size', canvas.width, canvas.height, 'state.dir', state.dir);
      loop();
    }
    function stopGame(){
      running=false; cancelAnimationFrame(rafId); 
      helmetHudTop.hidden=true; helmetHudBottom.hidden=true; crosshair.hidden=true;
      hud.hidden=true;
      document.body.classList.remove('playing');
      magicLayer.classList.remove('show'); magicLayer.setAttribute('aria-hidden','true');
      showOverlay(); resizeForDPR();
    }
    function toggleMenu(){ if(!running){ startGame(); } else { stopGame(); } }

    // Safe fullscreen helper (re-added to prevent ReferenceError halting loop)
    async function enterFullscreen(){
      if(!document.fullscreenElement){
        try {
          await document.documentElement.requestFullscreen();
        } catch(e) {
          console.warn('Fullscreen request failed:', e);
        }
      }
    }    // Fullscreen change -> ensure pointer lock if running
    document.addEventListener('fullscreenchange',()=>{ resizeForDPR(); if(running) lockPointer(); });

    // Remove cloning (caused loss of listener & potential TDZ issues)
    btnStart.addEventListener('click', startGame);
    btnFS.addEventListener('click',()=>{ const el=document.documentElement; if(!document.fullscreenElement){ el.requestFullscreen?.(); } else { document.exitFullscreen?.(); }});
    btnInvert.addEventListener('click',()=>{ state.invY=!state.invY; btnInvert.textContent='Invert Y: '+(state.invY?'Off':'On'); });

    // Hash autostart support
    if(location.hash.includes('autostart')){ setTimeout(()=> startGame(), 350); }

    const shell=document.getElementById('gameShell');
    let magicSpawned=false;
    function spawnOrbs(count=14){
      if(magicSpawned || !magicLayer) return; 
      magicSpawned=true;
      for(let i=0;i<count;i++){
        const orb=document.createElement('div');
        orb.className='magic-orb';
        const x=Math.random()*90+5; const y=Math.random()*80+10; const delay=Math.random()*12; const dur=10+Math.random()*10;
        orb.style.left=x+'%'; orb.style.top=y+'%'; orb.style.animationDuration=dur+'s'; orb.style.animationDelay='-'+delay+'s';
        magicLayer.appendChild(orb);
      }
    }
    // Remove immediate orb spawn; now deferred to startGame()
    // spawnOrbs();
    // Make buttons pulse magical
    document.getElementById('btnStart')?.classList.add('magic-pulse');
    document.getElementById('btnFS')?.classList.add('magic-pulse');
    window.addEventListener('load',()=>console.log('[maze] script ready, btnStart present?', !!btnStart));

    // Wall color function for shading
    function wallColor(mapX, mapY, dist, side){
      const baseL = 78 - Math.min(55, dist*4.5);
      const hue = side ? 200 : 195;
      const sat = 12 + Math.min(25, dist*2);
      return `hsl(${hue},${sat}%,${baseL}%)`;
    }
  })();
  </script>
</body>
</html>