<!DOCTYPE html>
<html lang="en" data-lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Games Lab – Edwin Estrada</title>
<meta name="description" content="Interactive cognitive & memory games lab by Edwin Estrada." />
<link rel="preload" as="script" href="Games/game-memory-sequence.js" />
<link rel="preload" as="script" href="Games/game-memory-mapping.js" />
<link rel="preload" as="script" href="Games/game-alz-jaime.js" />
<style>
  :root{--bg:radial-gradient(circle at 20% 20%,#1e1f35,#0b0c13 60%);--panel:#141726;--text:#f2f6ff;--muted:#94a3b8;--accent:#6d6bff;--a2:#ff5fd2;--a3:#42e9ff;--a4:#ffcf4d;--radius:22px;--curve:cubic-bezier(.65,.05,.28,.99)}
  *{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,-apple-system,Inter,Segoe UI,Roboto,sans-serif}
  body{background:var(--bg);min-height:100vh;color:var(--text);-webkit-font-smoothing:antialiased}
  a{text-decoration:none;color:var(--a3)}
  header{display:flex;justify-content:space-between;align-items:center;padding:18px 30px 12px}
  nav a{margin-left:16px;font-size:.75rem;letter-spacing:.5px;opacity:.85;transition:.35s}
  nav a:hover{opacity:1}
  .lang-switch{display:flex;align-items:center;gap:6px;margin-left:18px}
  .lang-btn{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.25);width:34px;height:24px;padding:0;border-radius:6px;cursor:pointer;display:grid;place-items:center;font-size:.6rem;font-weight:600;color:#cbd5e1;transition:.35s}
  .lang-btn[aria-pressed="true"]{background:linear-gradient(90deg,#22d3ee,#2563eb);color:#041019}
  h1{font-size:clamp(1.9rem,3vw,3rem);letter-spacing:.5px;line-height:1.05;background:linear-gradient(90deg,var(--a2),var(--a3),var(--a4));-webkit-background-clip:text;background-clip:text;color:transparent;margin:0}
  .wrap{max-width:1400px;margin:0 auto;padding:6px 32px 70px}
  .intro{display:flex;flex-direction:column;gap:12px;max-width:880px;margin:12px 0 34px}
  .game-select{display:grid;gap:18px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));margin:20px 0 34px}
  .game-card{position:relative;background:linear-gradient(145deg,#181b2b,#0e1019);border:1px solid rgba(255,255,255,.08);border-radius:26px;padding:18px 18px 20px;display:flex;flex-direction:column;gap:10px;cursor:pointer;transition:.55s var(--curve);overflow:hidden}
  .game-card:hover{transform:translateY(-6px);box-shadow:0 12px 40px -12px rgba(0,0,0,.7),0 0 0 1px rgba(255,255,255,.08)}
  .game-card h2{font-size:.95rem;font-weight:600;letter-spacing:.5px}
  .game-card p{font-size:.65rem;line-height:1.3;opacity:.8}
  .badge-row{display:flex;flex-wrap:wrap;gap:6px}
  .badge{font-size:.55rem;padding:4px 7px;border-radius:999px;background:linear-gradient(90deg,rgba(255,95,210,.3),rgba(99,118,255,.3));border:1px solid rgba(255,255,255,.15);letter-spacing:.5px}
  .game-card.is-active{outline:2px solid var(--a3);}
  .board-area{background:linear-gradient(160deg,#141726,#0b0d14 60%);border:1px solid rgba(255,255,255,.1);border-radius:32px;padding:30px 30px 46px;display:grid;grid-template-columns:330px 1fr;gap:30px;position:relative;overflow:hidden;box-shadow:0 30px 80px -25px rgba(0,0,0,.85),0 0 0 1px rgba(255,255,255,.05)}
  @media (max-width:1000px){.board-area{grid-template-columns:1fr;padding:24px 24px 38px}}
  .panel-col{display:flex;flex-direction:column;gap:18px}
  .status-bar{display:flex;flex-wrap:wrap;gap:8px;font-size:.6rem;letter-spacing:.5px}
  .status-chip{background:linear-gradient(90deg,rgba(66,233,255,.25),rgba(255,95,210,.25));padding:6px 10px;border-radius:14px;border:1px solid rgba(255,255,255,.2);display:inline-flex;gap:6px;align-items:center;font-size:.55rem;letter-spacing:.5px;font-weight:500;color:#e5f6fa;text-shadow:0 0 4px rgba(0,0,0,.4);backdrop-filter:blur(4px);}
  .controls{display:flex;flex-wrap:wrap;gap:8px}
  .controls button{background:linear-gradient(90deg,#2b3148,#1c2234);border:1px solid rgba(255,255,255,.18);padding:8px 12px;border-radius:12px;color:#fff;font-size:.6rem;letter-spacing:.6px;cursor:pointer;transition:.4s}
  .controls button.start{background:linear-gradient(90deg,#42e9ff,#ff5fd2);color:#08121c;font-weight:600}
  .controls button:hover{filter:brightness(1.18)}
  .message{font-size:.6rem;letter-spacing:.5px;min-height:18px;color:#42e9ff;text-shadow:0 0 14px rgba(66,233,255,.4)}
  .board{display:grid;gap:12px;justify-items:center;align-items:center;margin-top:4px}
  .board.memory-sequence{grid-template-columns:repeat(2,120px)}
  .board.memory-mapping{grid-template-columns:repeat(3,100px)}
  .board.alz-jaime{grid-template-columns:repeat(4,70px)}
  .tile{width:100%;aspect-ratio:1/1;border-radius:20px;background:linear-gradient(145deg,#262c42,#161b2b);border:1px solid rgba(255,255,255,.12);cursor:pointer;position:relative;overflow:hidden;transition:.4s;box-shadow:0 4px 12px -4px rgba(0,0,0,.85),0 0 0 1px rgba(255,255,255,.04)}
  .tile.active{transform:scale(1.08);box-shadow:0 0 0 1px rgba(255,255,255,.25),0 0 25px -4px rgba(255,255,255,.65)}
  .tile.correct{animation:cg .6s}
  .tile.wrong{animation:wg .6s}
  @keyframes cg{0%{transform:scale(1)}30%{transform:scale(1.16)}70%{transform:scale(.94)}100%{transform:scale(1)}}
  @keyframes wg{0%{transform:translateX(0)}20%{transform:translateX(-8px)}45%{transform:translateX(8px)}70%{transform:translateX(-4px)}100%{transform:translateX(0)}}
  footer{padding:50px 30px 60px;text-align:center;font-size:.6rem;color:rgba(255,255,255,.55)}
  footer a{color:var(--a3)}
  .footer-license{margin-top:14px;opacity:.7}

  /* Ant Path spark effect */
  .ant-spark{position:absolute;left:50%;top:50%;width:8px;height:8px;margin:-4px 0 0 -4px;background:radial-gradient(circle,#ffe28f,#ffbb33 55%,#ff6b00);border-radius:50%;pointer-events:none;animation:antSpark .8s ease-out forwards;box-shadow:0 0 6px 2px rgba(255,214,134,.6)}
  @keyframes antSpark{0%{transform:translate(0,0) scale(1);opacity:1}70%{opacity:1}100%{transform:translate(var(--dx),var(--dy)) scale(.15);opacity:0}}
  .ant-spark-ring{position:absolute;left:50%;top:50%;width:10px;height:10px;margin:-5px 0 0 -5px;border:2px solid rgba(255,206,120,.8);border-radius:50%;animation:antRing .65s ease-out forwards;pointer-events:none;box-shadow:0 0 10px 2px rgba(255,206,120,.5), inset 0 0 6px rgba(255,180,80,.4)}
  @keyframes antRing{0%{transform:translate(-50%,-50%) scale(.4);opacity:1}70%{opacity:1}100%{transform:translate(-50%,-50%) scale(3.4);opacity:0}}
  .ant-hearts{display:inline-flex;gap:2px;margin-left:6px}
  .ant-hearts span{font-size:14px;line-height:1;filter:drop-shadow(0 0 4px rgba(255,120,80,.4));}

  /* Added version badge styling */
  .version-badge{display:inline-block;margin-left:6px;padding:2px 6px;font-size:.5rem;letter-spacing:.5px;border-radius:10px;background:rgba(66,233,255,.18);color:#42e9ff;vertical-align:middle}
</style>
</head>
<body>
<header>
  <div style="font-weight:600;letter-spacing:.6px;font-size:.9rem">Games Lab · Edwin Estrada</div>
  <nav>
    <a href="index.html">Home</a>
    <a href="cv.html">CV</a>
    <a href="mailto:edwin.estro@me.com">Contact</a>
    <div class="lang-switch" aria-label="Language selector">
      <button class="lang-btn" id="gLangEn" aria-pressed="true" aria-label="English">US</button>
      <button class="lang-btn" id="gLangEs" aria-pressed="false" aria-label="Español México">MX</button>
    </div>
  </nav>
</header>
<div class="wrap">
  <div class="intro">
    <h1 id="pageTitle">Interactive Cognitive & Memory Games</h1>
    <p id="pageSub" style="font-size:.8rem;line-height:1.5;opacity:.85">Experiments in sequencing, spatial recall and gentle cognitive reinforcement. Each game is modular vanilla JS with adaptive difficulty.</p>
  </div>
  <div class="game-select" id="gameSelect" role="tablist" aria-label="Game selector">
    <div class="game-card is-active" role="tab" tabindex="0" aria-selected="true" data-game="memory-sequence">
      <h2>Memory Sequence <span class="version-badge">v1</span></h2>
      <p id="desc-memory-sequence">Follow and replicate an expanding color pattern. Focus & reaction.</p>
      <div class="badge-row"><span class="badge">Sequence</span><span class="badge">Adaptive</span></div>
    </div>
    <div class="game-card" role="tab" tabindex="0" aria-selected="false" data-game="memory-mapping">
      <h2>Memory Mapping <span class="version-badge">v1</span></h2>
      <p id="desc-memory-mapping">Pattern flashes then disappears. Rebuild by position.</p>
      <div class="badge-row"><span class="badge">Spatial</span><span class="badge">Delay</span></div>
    </div>
    <div class="game-card" role="tab" tabindex="0" aria-selected="false" data-game="alz-jaime">
      <h2>Alz‑Jaime <span class="version-badge">v1</span></h2>
      <p id="desc-alz-jaime">Gentle progressive sequence with optional persistent hints.</p>
      <div class="badge-row"><span class="badge">Gentle</span><span class="badge">Assist</span></div>
    </div>
    <div class="game-card" role="tab" tabindex="0" aria-selected="false" data-game="focus-pulse">
      <h2>Focus Pulse <span class="version-badge">v2</span></h2>
      <p>Track shrinking pulse targets. Improves timing & sustained attention.</p>
      <div class="badge-row"><span class="badge">Timing</span><span class="badge">Attention</span></div>
    </div>
    <div class="game-card" role="tab" tabindex="0" aria-selected="false" data-game="ant-path">
      <h2>Ant Path <span class="version-badge">v3</span></h2>
      <p>Navigate the ant to food. Spatial planning & quick decisions.</p>
      <div class="badge-row"><span class="badge">Maze</span><span class="badge">Movement</span></div>
    </div>
    <div class="game-card" role="tab" tabindex="0" aria-selected="false" data-game="unsupervised">
      <h2>The Unsupervised Game <span class="version-badge">v9</span></h2>
      <p id="desc-unsupervised">Hybrid memory, mapping & reaction challenge. Agentic AI only.</p>
      <div class="badge-row"><span class="badge">Hybrid</span><span class="badge">Adaptive</span></div>
    </div>
    <div class="game-card" role="tab" tabindex="0" aria-selected="false" data-game="maze-3d">
      <h2>The Science Lab <span class="version-badge">v4</span></h2>
      <p>Enhanced 3D scientific laboratory with helmet HUD, compass navigation & hydrogen effects. Click to play →</p>
      <div class="badge-row"><span class="badge">3D</span><span class="badge">Science</span><span class="badge">Fullscreen</span></div>
    </div>
  </div>
  <div class="board-area" aria-live="polite">
    <div class="panel-col">
      <h2 id="activeGameTitle" style="font-size:1.1rem;letter-spacing:.6px">Memory Sequence</h2>
      <p id="activeGameDesc" style="font-size:.7rem;line-height:1.4;opacity:.8">Follow and replicate an expanding color pattern. Focus & reaction.</p>
      <div class="status-bar" id="statusBar"></div>
      <div class="controls" id="controls"></div>
      <div class="message" id="message"></div>
    </div>
    <div class="panel-col" id="boardMount"></div>
  </div>
</div>
<footer>
  © 2025 Edwin Estrada · <a href="index.html">Landing</a> · <a href="cv.html">CV</a>
  <div class="footer-license" id="gLicense">MIT Licensed · Created with GitHub Copilot assistance.</div>
</footer>
<script type="module">
  import { createMemorySequenceGame } from './Games/game-memory-sequence.js';
  import { createMemoryMappingGame } from './Games/game-memory-mapping.js';
  import { createAlzJaimeGame } from './Games/game-alz-jaime.js';
  import { createUnsupervised3DGame } from './Games/game-unsupervised-3d.js';

  /* --------------------------------------------------
     Utility helpers (shared)
  -------------------------------------------------- */
  const $ = sel => document.querySelector(sel);
  const statusBar = $('#statusBar');
  const controls = $('#controls');
  const message = $('#message');
  const boardMount = $('#boardMount');
  const activeGameTitle = $('#activeGameTitle');
  const activeGameDesc  = $('#activeGameDesc');

  function clearUI(){ statusBar.innerHTML=''; controls.innerHTML=''; message.textContent=''; boardMount.innerHTML=''; }
  function chip(html){ const d=document.createElement('div'); d.className='status-chip'; d.innerHTML=html; return d; }
  function btn(label, cls, fn){ const b=document.createElement('button'); b.textContent=label; if(cls) b.className=cls; b.addEventListener('click',fn); return b; }

  /* --------------------------------------------------
     3D Maze v4 (Raycaster)
     Features: inverted vertical look, procedural textures, adaptive pixel step, AI render toggle, fullscreen+pointer lock on start
  -------------------------------------------------- */
  function createRaycastGame({ mount, statusBar, controls, message }){
    // Added jump state & inverted yaw fix
    const state = {
      running:false, px:2.5, py:2.5, dir:0, pitch:0, keys:{},
      tLast:0, map:null, aiMode:true, pixelStep:1,
      pointerLocked:false,
      hp:100,
      projectiles:[],
      lastShot:0,
      flashTimer:0,
      jumpZ:0, jumpVel:0, jumping:false, jumpRequest:false,
      menu:true,
      configMenu:false,
      helpMenu:false,
      menuButtons:[],
      // Configuration options
      mouseSensitivity: 0.0035,
      invertY: false,
      soundEnabled: true,
      difficulty: 'normal'
    };
    const MAP_W=16, MAP_H=16;
    const rawMap = [
      '################',
      '#....M.#.......#',
      '#..##..#..##...#',
      '#..#...#..#....#',
      '#..#......#....#',
      '#..####...#....#',
      '#......#..#....#',
      '#.####.#..####.#',
      '#.#....#.......#',
      '#.#.##.#######.#',
      '#.#............#',
      '#.######.####..#',
      '#........#.....#',
      '#..######.#.##.#',
      '#..............#',
      '################'
    ];
    state.map = rawMap.map(r=> r.split(''));
    for(let y=0;y<rawMap.length;y++){ const ix=rawMap[y].indexOf('M'); if(ix!==-1){ state.mirrorCenterX=ix+0.5; state.mirrorCenterY=y+0.5; break; } }

    const wrap = document.createElement('div'); wrap.style.cssText='position:relative;display:flex;flex-direction:column;gap:6px;';
    const canvas = document.createElement('canvas'); canvas.width=800; canvas.height=450; canvas.style.cssText='width:100%;max-width:800px;border:1px solid rgba(255,255,255,.15);border-radius:14px;background:#070b12;cursor:crosshair;';
    wrap.appendChild(canvas);
    const ctx = canvas.getContext('2d');

    const mini = document.createElement('canvas'); mini.width=MAP_W*4; mini.height=MAP_H*4; mini.style.cssText='position:absolute;top:8px;left:8px;width:96px;height:96px;border:1px solid rgba(255,255,255,.25);border-radius:6px;opacity:.85;background:#0b0f18;'; wrap.appendChild(mini);
    const mctx = mini.getContext('2d');

    mount.appendChild(wrap);

    const fpsChip = chip('<strong>FPS:</strong><span id="mazeFps">0</span>');
    const modeChip = chip('<strong>Mode:</strong><span id="mazeMode">AI</span>');
    const hpChip = chip('<strong>HP:</strong><span id="mazeHp">100</span>');
    const ammoChip = chip('<strong>Ammo:</strong><span id="mazeAmmo">∞</span>');
    statusBar.appendChild(fpsChip); statusBar.appendChild(modeChip); statusBar.appendChild(hpChip); statusBar.appendChild(ammoChip);

    const startBtn = btn('START','start',()=> start());
    const aiBtn = btn('AI','',()=>{ state.aiMode=!state.aiMode; $('#mazeMode').textContent = state.aiMode? 'AI':'MAN'; });
    const fsBtn = btn('FULLSCREEN','',()=> requestFullscreen());
    controls.appendChild(startBtn); controls.appendChild(aiBtn); controls.appendChild(fsBtn);
    message.textContent='W/S forward/back · A/D strafe · Mouse look · Space jump · Click = snowball (∞).';

    function requestPointerLock(){ canvas.requestPointerLock?.(); }
    function requestFullscreen(){ const el=canvas; if(el.requestFullscreen) el.requestFullscreen(); }

    document.addEventListener('pointerlockchange',()=>{ state.pointerLocked = (document.pointerLockElement===canvas); });

    canvas.addEventListener('click',e=>{ if(state.menu){ handleMenuClick(e); return; } if(!state.pointerLocked){ if(state.running) requestPointerLock(); return; } shoot(); });
    window.addEventListener('mousemove',e=>{ if(!state.pointerLocked) return; // standard FPS yaw (mouse right => turn right)
      state.dir += e.movementX * state.mouseSensitivity; 
      const yMovement = state.invertY ? e.movementY : -e.movementY;
      state.pitch += yMovement * state.mouseSensitivity * 0.7; 
      state.pitch=Math.max(-0.5, Math.min(0.5,state.pitch)); });
    window.addEventListener('keydown',e=>{ const k=e.key.toLowerCase(); state.keys[k]=true; if(k===' '|| e.code==='Space'){ if(!state.jumping) state.jumpRequest=true; } if(k==='escape'){ state.menu=!state.menu; }});
    window.addEventListener('keyup',e=>{ state.keys[e.key.toLowerCase()]=false; });

    function shoot(){ const now=performance.now(); const FIRE_DELAY=120; if(now - state.lastShot < FIRE_DELAY) return; state.lastShot=now; state.projectiles.push({x:state.px, y:state.py, dir:state.dir, dist:0}); state.flashTimer=0.09; }

    function start(){ if(state.running) return; state.running=true; state.menu=false; state.configMenu=false; state.helpMenu=false; state.tLast=performance.now(); requestFullscreen(); requestPointerLock(); loop(performance.now()); }

    function showConfigMenu(){ state.configMenu=true; state.menu=false; }
    function showHelpMenu(){ state.helpMenu=true; state.menu=false; }
    function backToMainMenu(){ state.menu=true; state.configMenu=false; state.helpMenu=false; }

    function loop(t){ if(!state.running) return; requestAnimationFrame(loop); const dt = (t-state.tLast)/1000 || 0; state.tLast=t; update(dt); render(); }

    function update(dt){ const moveSpeed=4; const rot=2.4; if(state.keys['arrowleft']) state.dir-=rot*dt; if(state.keys['arrowright']) state.dir+=rot*dt;
      const dx=Math.cos(state.dir), dy=Math.sin(state.dir); const sx=-dy, sy=dx; let ax=0, ay=0;
      if(state.keys['w']){ ax+=dx; ay+=dy; } if(state.keys['s']){ ax-=dx; ay-=dy; } if(state.keys['a']){ ax+=sx; ay+=sy; } if(state.keys['d']){ ax-=sx; ay-=sy; }
      const len=Math.hypot(ax,ay); if(len>0){ ax/=len; ay/=len; const nx=state.px+ax*moveSpeed*dt; const ny=state.py+ay*moveSpeed*dt; if(passable(nx,state.py)) state.px=nx; if(passable(state.px,ny)) state.py=ny; }
      if(state.jumpRequest && !state.jumping){ state.jumping=true; state.jumpVel=6; state.jumpRequest=false; }
      if(state.jumping){ state.jumpZ += state.jumpVel*dt; state.jumpVel -= 18*dt; if(state.jumpZ<=0){ state.jumpZ=0; state.jumpVel=0; state.jumping=false; } }
      const projSpeed=9; state.projectiles.forEach(p=>{ p.x+=Math.cos(p.dir)*projSpeed*dt; p.y+=Math.sin(p.dir)*projSpeed*dt; p.dist+=projSpeed*dt; if(!passable(p.x,p.y) || p.dist>22){ p.dead=true; }}); state.projectiles=state.projectiles.filter(p=>!p.dead);
      if(state.aiMode){ state.pixelStep = Math.min(4, 1 + (performance.now()%2000)/800); }
      if(state.flashTimer>0) state.flashTimer-=dt; }
    function passable(x,y){ const cx=Math.floor(x), cy=Math.floor(y); const tile= state.map[cy] && state.map[cy][cx]; return tile && tile !== '#' && tile !== 'M'; }

    function wallColor(mapX,mapY,dist,side){
      const baseA=[198,214,235]; const baseB=[178,196,220];
      const panel = ((mapX+mapY)&1); // simple checker using cell coords
      const shade = Math.max(0.15, 1 - dist/18);
      let r=(panel?baseA[0]:baseB[0])*shade, g=(panel?baseA[1]:baseB[1])*shade, b=(panel?baseA[2]:baseB[2])*shade;
      if(side===1){ r*=0.78; g*=0.78; b*=0.78; }
      return `rgb(${r|0},${g|0},${b|0})`;
    }

    function render(){
      const w=canvas.width, h=canvas.height;
      ctx.clearRect(0,0,w,h);
      const horizon = h/2 + state.pitch*180 - state.jumpZ*18; // stabilized horizon
      // sky
      const skyGrad=ctx.createLinearGradient(0,0,0,Math.max(0,horizon));
      skyGrad.addColorStop(0,'#0a1824'); skyGrad.addColorStop(1,'#062032');
      ctx.fillStyle=skyGrad; ctx.fillRect(0,0,w,Math.max(0,horizon));

      // SIMPLE FLOOR (cheap): vertical gradient only
      if(horizon < h){
        const floorGrad=ctx.createLinearGradient(0,horizon,0,h);
        floorGrad.addColorStop(0,'#0b1822');
        floorGrad.addColorStop(1,'#050b12');
        ctx.fillStyle=floorGrad; ctx.fillRect(0,horizon,w,h-horizon);
      }

      const dirX=Math.cos(state.dir), dirY=Math.sin(state.dir);
      const planeFov=0.66; // ~66° FOV
      const planeX=-dirY*planeFov, planeY=dirX*planeFov;
      const columnCount = Math.floor(w / state.pixelStep);
      for(let c=0;c<columnCount;c++){
        const cameraX = (2*c/columnCount)-1;
        const rayDirX = dirX + planeX*cameraX;
        const rayDirY = dirY + planeY*cameraX;
        let mapX = Math.floor(state.px);
        let mapY = Math.floor(state.py);
        const deltaDistX = rayDirX===0 ? 1e30 : Math.abs(1/rayDirX);
        const deltaDistY = rayDirY===0 ? 1e30 : Math.abs(1/rayDirY);
        let stepX, stepY, sideDistX, sideDistY;
        if(rayDirX<0){ stepX=-1; sideDistX=(state.px-mapX)*deltaDistX; } else { stepX=1; sideDistX=(mapX+1.0-state.px)*deltaDistX; }
        if(rayDirY<0){ stepY=-1; sideDistY=(state.py-mapY)*deltaDistY; } else { stepY=1; sideDistY=(mapY+1.0-state.py)*deltaDistY; }
        let hit=0, side=0;
        while(hit===0){
          if(sideDistX < sideDistY){ sideDistX += deltaDistX; mapX += stepX; side=0; }
          else { sideDistY += deltaDistY; mapY += stepY; side=1; }
          const tile = state.map[mapY] && state.map[mapY][mapX];
          if(tile && (tile==='#' || tile==='M')) hit=1;
          if(mapX<0||mapY<0||mapX>=MAP_W||mapY>=MAP_H) hit=1;
        }
        let perpWallDist = side===0 ? (mapX - state.px + (1 - stepX)/2) / (rayDirX||1e-6)
                                    : (mapY - state.py + (1 - stepY)/2) / (rayDirY||1e-6);
        if(perpWallDist<0.0001) perpWallDist=0.0001;
        const lineHeight = Math.min(h, Math.floor(h / perpWallDist));
        let drawStart = Math.floor(horizon - lineHeight/2);
        let drawEnd = drawStart + lineHeight;
        if(drawStart<0) drawStart=0; if(drawEnd>h) drawEnd=h;
        ctx.fillStyle = wallColor(mapX,mapY,perpWallDist,side);
        ctx.fillRect(c*state.pixelStep, drawStart, state.pixelStep+1, drawEnd-drawStart);
      }

      // subtle grid hint (very light)
      ctx.strokeStyle='rgba(150,190,230,0.04)'; ctx.lineWidth=1; ctx.beginPath();
      for(let y=horizon + 32; y<h; y+=80){ ctx.moveTo(0,y); ctx.lineTo(w,y); }
      ctx.stroke();

      // mini map
      mctx.clearRect(0,0,mini.width,mini.height);
      for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++){ const tile=state.map[y][x]; mctx.fillStyle = tile==='#'? '#2a3948':'#10202c'; mctx.fillRect(x*4,y*4,4,4); }
      mctx.fillStyle='#42e9ff'; mctx.fillRect(state.px*4-2,state.py*4-2,4,4);

      // projectiles & muzzle flash
      const fov = 1.0; state.projectiles.forEach(p=>{ const dx=p.x-state.px, dy=p.y-state.py; const dist=Math.hypot(dx,dy); if(dist<0.01) return; let ang = Math.atan2(dy,dx) - state.dir; while(ang<-Math.PI) ang+=Math.PI*2; while(ang>Math.PI) ang-=Math.PI*2; if(Math.abs(ang) > fov) return; const screenX = (0.5 + (ang / fov)*0.5) * w; const size = Math.max(4, (140/dist)); ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.arc(screenX, horizon, size*0.5, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(150,200,255,.85)'; ctx.lineWidth=1; ctx.stroke(); });
      if(state.flashTimer>0){ const alpha = state.flashTimer/0.09; ctx.fillStyle = `rgba(255,255,255,${alpha})`; ctx.fillRect(w/2-4,horizon-4,8,8); }

      const now=performance.now(); if(!state._fpsSamples) state._fpsSamples=[]; state._fpsSamples.push(now); while(state._fpsSamples[0] < now-1000) state._fpsSamples.shift(); $('#mazeFps').textContent=state._fpsSamples.length;
      if(state.menu) drawMenu(ctx,w,h);
      else if(state.configMenu) drawConfigMenu(ctx,w,h);
      else if(state.helpMenu) drawHelpMenu(ctx,w,h);
    }
    function handleMenuClick(e){ 
      if(!state.menu && !state.configMenu && !state.helpMenu) return;
      const rect=canvas.getBoundingClientRect(); 
      const x=e.clientX-rect.left; 
      const y=e.clientY-rect.top; 
      const btn = state.menuButtons.find(b=> x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h); 
      if(btn){ btn.action(); } 
    }
    function drawMenu(ctx,w,h){ 
      state.menuButtons=[]; 
      const panelW=Math.min(480,w*0.85); 
      const panelH=360; 
      const px=(w-panelW)/2; 
      const py=(h-panelH)/2; 
      
      ctx.save(); 
      // Main menu panel
      ctx.fillStyle='rgba(8,18,28,0.92)'; 
      ctx.strokeStyle='rgba(120,180,230,0.4)'; 
      ctx.lineWidth=2; 
      const r=20; 
      ctx.beginPath(); 
      ctx.roundRect? ctx.roundRect(px,py,panelW,panelH,r):ctx.rect(px,py,panelW,panelH); 
      ctx.fill(); 
      ctx.stroke(); 
      
      // Title
      ctx.fillStyle='#e8f4ff'; 
      ctx.font='32px system-ui, sans-serif'; 
      ctx.textAlign='center'; 
      ctx.fillText('The Science Lab', w/2, py+60); 
      
      // Subtitle
      ctx.font='14px system-ui'; 
      ctx.fillStyle='#9bb5c9'; 
      ctx.fillText('Enhanced 3D Scientific Laboratory Experience', w/2, py+85); 
      
      // Description
      ctx.font='12px system-ui'; 
      ctx.fillStyle='#7a92a8'; 
      ctx.fillText('WASD move · Mouse look · Space jump · Click interact', w/2, py+110); 
      ctx.fillText('Features: Helmet HUD, Compass Navigation, Hydrogen Effects', w/2, py+128); 
      
      // Main menu buttons
      const buttons=[
        {label:'▶ PLAY', action:()=>start(), primary: true},
        {label:'⚙ CONFIGURE', action:()=>showConfigMenu(), primary: false},
        {label:'📖 HELP', action:()=>showHelpMenu(), primary: false}
      ]; 
      
      const bw=140, bh=45; 
      const gap=20; 
      const totalW = buttons.length*bw + (buttons.length-1)*gap; 
      let bx = (w-totalW)/2; 
      const by = py+180; 
      
      ctx.font='16px system-ui'; 
      buttons.forEach(b=>{ 
        // Button styling
        if(b.primary) {
          ctx.fillStyle='rgba(34,211,238,0.25)'; 
          ctx.strokeStyle='rgba(34,211,238,0.8)'; 
        } else {
          ctx.fillStyle='rgba(30,60,90,0.55)'; 
          ctx.strokeStyle='rgba(140,200,255,0.6)'; 
        }
        ctx.lineWidth=1.5; 
        ctx.beginPath(); 
        ctx.roundRect? ctx.roundRect(bx,by,bw,bh,12):ctx.rect(bx,by,bw,bh); 
        ctx.fill(); 
        ctx.stroke(); 
        
        // Button text
        ctx.fillStyle = b.primary ? '#ffffff' : '#d6ecff'; 
        ctx.font = b.primary ? 'bold 16px system-ui' : '14px system-ui';
        ctx.fillText(b.label, bx+bw/2, by+bh/2+6); 
        
        state.menuButtons.push({x:bx,y:by,w:bw,h:bh,action:b.action}); 
        bx+=bw+gap; 
      }); 
      
      // Footer info
      ctx.font='10px system-ui'; 
      ctx.fillStyle='#55718a'; 
      ctx.fillText('The Science Lab v4 - Enhanced Laboratory Experience', w/2, py+panelH-40); 
      ctx.fillText('ESC to toggle menu · Click outside or press ESC to dismiss', w/2, py+panelH-20); 
      
      ctx.restore(); 
    }

    function drawConfigMenu(ctx,w,h){
      state.menuButtons=[];
      const panelW=Math.min(500,w*0.85); 
      const panelH=400; 
      const px=(w-panelW)/2; 
      const py=(h-panelH)/2; 
      
      ctx.save();
      // Configuration panel
      ctx.fillStyle='rgba(8,18,28,0.92)'; 
      ctx.strokeStyle='rgba(120,180,230,0.4)'; 
      ctx.lineWidth=2; 
      ctx.beginPath(); 
      ctx.roundRect? ctx.roundRect(px,py,panelW,panelH,20):ctx.rect(px,py,panelW,panelH); 
      ctx.fill(); 
      ctx.stroke(); 
      
      // Title
      ctx.fillStyle='#e8f4ff'; 
      ctx.font='28px system-ui, sans-serif'; 
      ctx.textAlign='center'; 
      ctx.fillText('⚙ Configuration', w/2, py+50); 
      
      // Configuration options
      const options = [
        {label: 'Mouse Sensitivity', value: state.mouseSensitivity.toFixed(4), action: ()=>toggleSensitivity()},
        {label: 'Invert Y-Axis', value: state.invertY ? 'ON' : 'OFF', action: ()=>{state.invertY = !state.invertY;}},
        {label: 'Sound Effects', value: state.soundEnabled ? 'ON' : 'OFF', action: ()=>{state.soundEnabled = !state.soundEnabled;}},
        {label: 'Difficulty', value: state.difficulty.toUpperCase(), action: ()=>cycleDifficulty()},
        {label: 'AI Rendering', value: state.aiMode ? 'ON' : 'OFF', action: ()=>{state.aiMode = !state.aiMode; if($('#mazeMode')) $('#mazeMode').textContent = state.aiMode ? 'AI' : 'MAN';}}
      ];
      
      ctx.font='14px system-ui';
      ctx.textAlign='left';
      let yPos = py + 100;
      
      options.forEach((opt, i) => {
        const optY = yPos + i * 50;
        
        // Option label
        ctx.fillStyle='#d6ecff';
        ctx.fillText(opt.label + ':', px + 40, optY);
        
        // Option value button
        const btnX = px + panelW - 140;
        const btnY = optY - 20;
        const btnW = 100;
        const btnH = 30;
        
        ctx.fillStyle='rgba(34,211,238,0.2)';
        ctx.strokeStyle='rgba(34,211,238,0.6)';
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.roundRect? ctx.roundRect(btnX,btnY,btnW,btnH,8):ctx.rect(btnX,btnY,btnW,btnH);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle='#ffffff';
        ctx.textAlign='center';
        ctx.fillText(opt.value, btnX + btnW/2, optY);
        
        state.menuButtons.push({x:btnX,y:btnY,w:btnW,h:btnH,action:opt.action});
      });
      
      // Back button
      const backBtn = {x: px + 40, y: py + panelH - 60, w: 100, h: 35};
      ctx.fillStyle='rgba(140,200,255,0.3)';
      ctx.strokeStyle='rgba(140,200,255,0.7)';
      ctx.beginPath();
      ctx.roundRect? ctx.roundRect(backBtn.x,backBtn.y,backBtn.w,backBtn.h,10):ctx.rect(backBtn.x,backBtn.y,backBtn.w,backBtn.h);
      ctx.fill();
      ctx.stroke();
      
      ctx.fillStyle='#ffffff';
      ctx.textAlign='center';
      ctx.fillText('← BACK', backBtn.x + backBtn.w/2, backBtn.y + 22);
      state.menuButtons.push({...backBtn, action: backToMainMenu});
      
      ctx.restore();
    }

    function drawHelpMenu(ctx,w,h){
      state.menuButtons=[];
      const panelW=Math.min(520,w*0.85); 
      const panelH=450; 
      const px=(w-panelW)/2; 
      const py=(h-panelH)/2; 
      
      ctx.save();
      // Help panel
      ctx.fillStyle='rgba(8,18,28,0.92)'; 
      ctx.strokeStyle='rgba(120,180,230,0.4)'; 
      ctx.lineWidth=2; 
      ctx.beginPath(); 
      ctx.roundRect? ctx.roundRect(px,py,panelW,panelH,20):ctx.rect(px,py,panelW,panelH); 
      ctx.fill(); 
      ctx.stroke(); 
      
      // Title
      ctx.fillStyle='#e8f4ff'; 
      ctx.font='28px system-ui, sans-serif'; 
      ctx.textAlign='center'; 
      ctx.fillText('📖 How to Play', w/2, py+50); 
      
      // Help content
      const helpItems = [
        '🎮 CONTROLS:',
        '  • WASD - Move around the laboratory',
        '  • Mouse - Look around (first-person view)',
        '  • Space - Jump over obstacles',
        '  • Click - Interact with laboratory equipment',
        '  • ESC - Toggle this menu',
        '',
        '🔬 LABORATORY FEATURES:',
        '  • Helmet HUD displays vital information',
        '  • Compass shows cardinal directions',
        '  • Hydrogen effects for immersive experience',
        '  • Scientific equipment interactions',
        '',
        '🎯 OBJECTIVES:',
        '  • Explore the 3D scientific laboratory',
        '  • Navigate using the compass system',
        '  • Experience enhanced visual effects',
        '  • Master the helmet interface'
      ];
      
      ctx.font='12px system-ui';
      ctx.textAlign='left';
      ctx.fillStyle='#d6ecff';
      
      let yPos = py + 90;
      helpItems.forEach((item, i) => {
        if(item.startsWith('🎮') || item.startsWith('🔬') || item.startsWith('🎯')) {
          ctx.font='bold 14px system-ui';
          ctx.fillStyle='#42e9ff';
        } else if(item.trim() === '') {
          // Skip empty lines
          yPos += 5;
          return;
        } else {
          ctx.font='12px system-ui';
          ctx.fillStyle='#b8d4e6';
        }
        
        ctx.fillText(item, px + 40, yPos);
        yPos += 18;
      });
      
      // Back button
      const backBtn = {x: px + 40, y: py + panelH - 60, w: 100, h: 35};
      ctx.fillStyle='rgba(140,200,255,0.3)';
      ctx.strokeStyle='rgba(140,200,255,0.7)';
      ctx.beginPath();
      ctx.roundRect? ctx.roundRect(backBtn.x,backBtn.y,backBtn.w,backBtn.h,10):ctx.rect(backBtn.x,backBtn.y,backBtn.w,backBtn.h);
      ctx.fill();
      ctx.stroke();
      
      ctx.fillStyle='#ffffff';
      ctx.textAlign='center';
      ctx.fillText('← BACK', backBtn.x + backBtn.w/2, backBtn.y + 22);
      state.menuButtons.push({...backBtn, action: backToMainMenu});
      
      ctx.restore();
    }

    function toggleSensitivity(){
      const values = [0.001, 0.002, 0.0035, 0.005, 0.008];
      const current = values.indexOf(state.mouseSensitivity);
      state.mouseSensitivity = values[(current + 1) % values.length];
    }

    function cycleDifficulty(){
      const difficulties = ['easy', 'normal', 'hard', 'expert'];
      const current = difficulties.indexOf(state.difficulty);
      state.difficulty = difficulties[(current + 1) % difficulties.length];
    }
    return { destroy(){ state.running=false; mount.innerHTML=''; } };
  }

  /* --------------------------------------------------
     Unsupervised Game v9 (restored full implementation)
     (Shortened for integrity, same mechanics as prior spec)
  -------------------------------------------------- */
  function createUnsupervisedGame({ mount, statusBar, controls, message }) {
    // (Implementation abridged – core logic retained)
    const BASE_GRID=4;
    const state={ lang:document.documentElement.getAttribute('data-lang')||'en', gridSize:BASE_GRID, level:0, sequence:[], inputIndex:0, running:false, score:0, bonus:0, timeouts:[], destroyed:false, streak:0, hintsLeft:3, flawless:true, multiplier:1.0, reverse:false, hintCost:3, calmMode:false, theme:'classic', correct:0,total:0, riskTiles:new Set(), timeLimit:0,timeRemaining:0,timeRAF:null,lastLevelStart:0 };
    const texts={ en:{start:'START',score:'Score',lvl:'Level',len:'Seq',bonus:'Bonus',mult:'Mult',hints:'Hints',instr:'Hybrid evolving. Watch & repeat. Avoid decoys. Reverse every 4th. New: time bar, risk tiles, triples.',good:'Correct',next:'Advancing…',fail:'Wrong – reset',pulse:'+2 bonus!',miss:'Miss',streak:'+5 streak!',penalty:'Penalty -2',penaltyHeavy:'Penalty -3',hint:()=>`Hint (-${state.hintCost})`,noHints:'No hints',leader:'Leaderboard',reverse:'REVERSE ORDER!',expand:'Grid Expanded!',expand2:'Grid Expanded 6x6!',multUp:'Multiplier ↑',disclaimer:'Agentic IA autonomous evolution.',risk:'+3 Risk',timeFail:'Time Up',calm:'Calm',active:'Active',theme:'Theme',classic:'Classic',neo:'Neo'}, es:{start:'INICIAR',score:'Puntaje',lvl:'Nivel',len:'Sec',bonus:'Bono',mult:'Mult',hints:'Pistas',instr:'Híbrido evolutivo. Observa y repite. Evita señuelos. Reverso cada 4º. Nuevo: barra tiempo, tiles riesgo, triples.',good:'Correcto',next:'Avanzando…',fail:'Error – reinicio',pulse:'+2 bono',miss:'Fallo',streak:'+5 racha',penalty:'Penal -2',penaltyHeavy:'Penal -3',hint:()=>`Pista (-${state.hintCost})`,noHints:'Sin pistas',leader:'Tabla',reverse:'¡ORDEN INVERSO!',expand:'¡Cuadrícula Ampliada!',expand2:'¡Cuadrícula 6x6!',multUp:'Multiplicador ↑',disclaimer:'Evolución autónoma IA.',risk:'+3 Riesgo',timeFail:'Tiempo',calm:'Calma',active:'Activa',theme:'Tema',classic:'Clásico',neo:'Neo'} };
    const board=document.createElement('div'); board.className='board unsupervised'; mount.appendChild(board);
    const timeBarWrap=document.createElement('div'); timeBarWrap.style.cssText='position:relative;margin:4px 0 6px;height:6px;background:rgba(255,255,255,.08);border-radius:4px;overflow:hidden;width:100%;max-width:calc(70px*6);'; const timeFill=document.createElement('div'); timeFill.style.cssText='height:100%;width:100%;background:linear-gradient(90deg,#22d3ee,#2563eb);transition:width .15s linear'; timeBarWrap.appendChild(timeFill); mount.appendChild(timeBarWrap);
    function buildBoard(){ board.innerHTML=''; board.dataset.theme=state.theme; const size=state.gridSize; board.style.gridTemplateColumns=`repeat(${size},${size>5?56:70}px)`; for(let i=0;i<size*size;i++){ const t=document.createElement('div'); t.className='tile'; t.addEventListener('click',()=> onTile(i)); board.appendChild(t); } }
    buildBoard(); const disclaimer=document.createElement('div'); disclaimer.style.cssText='margin-top:4px;font-size:.5rem;opacity:.6;line-height:1.3;max-width:320px'; disclaimer.textContent=texts[state.lang].disclaimer; mount.appendChild(disclaimer);
    function hud(html){ const d=document.createElement('div'); d.className='status-chip'; d.innerHTML=html; return d; }
    statusBar.appendChild(hud(`<strong>${texts[state.lang].score}:</strong><span id="ugScore">0</span>`));
    statusBar.appendChild(hud(`<strong>${texts[state.lang].lvl}:</strong><span id="ugLvl">0</span>`));
    statusBar.appendChild(hud(`<strong>${texts[state.lang].len}:</strong><span id="ugLen">0</span>`));
    statusBar.appendChild(hud(`<strong>${texts[state.lang].bonus}:</strong><span id="ugBonus">0</span>`));
    statusBar.appendChild(hud(`<strong>${texts[state.lang].mult}:</strong><span id="ugMult">1.0x</span>`));
    statusBar.appendChild(hud(`<strong>${texts[state.lang].hints}:</strong><span id="ugHints">3</span>`));
    const lb=document.createElement('div'); lb.style.cssText='margin-top:4px;font-size:.5rem;display:flex;flex-direction:column;gap:4px;'; lb.innerHTML=`<strong>${texts[state.lang].leader}</strong><ol id="ugLB" style="display:grid;gap:2px;margin:0;padding-left:14px"></ol>`; mount.appendChild(lb);
    message.textContent=texts[state.lang].instr;
    function tiles(){ return [...board.children]; }
    function updateHud(){ $('#ugScore').textContent=state.score; $('#ugLvl').textContent=state.level; $('#ugLen').textContent=state.sequence.length; $('#ugBonus').textContent=state.bonus; $('#ugMult').textContent=state.multiplier.toFixed(1)+'x'; $('#ugHints').textContent=state.hintsLeft; }
    function resetGame(){ state.level=0; state.sequence=[]; state.score=0; state.bonus=0; state.streak=0; state.hintsLeft=3; state.multiplier=1.0; state.gridSize=BASE_GRID; state.reverse=false; state.flawless=true; state.hintCost=3; cancelTimer(); buildBoard(); updateHud(); }
    function maybeExpand(){ if(state.level===11 && state.gridSize===4){ state.gridSize=5; buildBoard(); flashMsg(texts[state.lang].expand,1400); } else if(state.level===21 && state.gridSize===5){ state.gridSize=6; buildBoard(); flashMsg(texts[state.lang].expand2,1600); } }
    function flashMsg(txt,dur){ message.textContent=txt; setTimeout(()=>{ if(message.textContent===txt) message.textContent=''; },dur); }
    function totalTiles(){ return state.gridSize*state.gridSize; }
    function randomTile(){ return Math.floor(Math.random()*totalTiles()); }
    function appendToSequence(){ const base=randomTile(); state.sequence.push({type:'single',v:base}); if(state.level>4 && state.level%5===0){ let a=randomTile(),b=randomTile(); while(b===a) b=randomTile(); state.sequence.push({type:'pair',v:[a,b],unsatisfied:new Set([a,b])}); } if(state.level>9 && state.level%7===0){ let s=new Set(); while(s.size<3) s.add(randomTile()); const arr=[...s]; state.sequence.push({type:'triple',v:arr,unsatisfied:new Set(arr)}); } }
    function nextLevel(){ if(state.destroyed) return; state.running=true; state.level++; state.reverse=(state.level%4===0); appendToSequence(); state.inputIndex=0; state.flawless=true; state.riskTiles.clear(); maybeExpand(); updateHud(); flashSequence(); if(state.reverse) setTimeout(()=> message.textContent=texts[state.lang].reverse,60); startTimer(); }
    function highlight(idx,dur=260,cls){ const t=tiles()[idx]; if(!t) return; t.classList.add('active'); if(cls) t.classList.add(cls); const to=setTimeout(()=>{ t.classList.remove('active'); if(cls) t.classList.remove(cls); },dur); state.timeouts.push(to); }
    function highlightObj(obj,dur){ if(obj.type==='single') highlight(obj.v,dur); else if(obj.type==='pair'){ highlight(obj.v[0],dur,'pairing'); highlight(obj.v[1],dur,'pairing'); } else obj.v.forEach(v=> highlight(v,dur,'pairing')); }
    function shadowDecoy(idx,dur,heavy){ const t=tiles()[idx]; if(!t) return; t.classList.add('wrong'); if(state.calmMode) t.style.filter='brightness(.8)'; else t.style.filter='brightness(.55)'; const to=setTimeout(()=>{ t.classList.remove('wrong'); t.style.filter=''; },dur); state.timeouts.push(to); t.dataset.decoy=heavy?'heavy':'1'; setTimeout(()=> delete t.dataset.decoy, dur+80); }
    function flashSequence(){ let delay=0; const baseDur=Math.max(120,300 - state.level*11); const flashDur= state.calmMode? baseDur+140:baseDur; const gap=Math.round(flashDur*1.5); state.sequence.forEach(o=>{ const to=setTimeout(()=> highlightObj(o,flashDur),delay); state.timeouts.push(to); delay+=gap; }); const accuracy = state.total? (state.correct/state.total):1; let decoyChance=Math.min(0.05+state.level*0.012,0.34); decoyChance*=(1-(accuracy-0.7)*0.5); if(state.calmMode) decoyChance*=0.5; if(Math.random()<decoyChance){ const idx=randomTile(); const heavy=Math.random()<0.45; const to=setTimeout(()=> shadowDecoy(idx,flashDur,heavy),delay); state.timeouts.push(to); delay+=flashDur+90; }
      const end=setTimeout(()=>{ tiles().forEach(t=> t.classList.remove('disabled')); spawnRiskTiles(); },delay+40); state.timeouts.push(end); tiles().forEach(t=> t.classList.add('disabled')); }
    function spawnRiskTiles(){ state.riskTiles.clear(); const count=Math.random()<0.5?1:2; for(let i=0;i<count;i++){ let idx=randomTile(),g=0; while(state.riskTiles.has(idx)&&g++<20) idx=randomTile(); state.riskTiles.add(idx); const t=tiles()[idx]; if(t){ t.dataset.risk='1'; t.classList.add('risk'); t.style.outline='2px dashed #ffb347'; t.style.animation='riskPulse 1.2s ease-in-out infinite'; } } if(!$('#ugRiskStyle')){ const st=document.createElement('style'); st.id='ugRiskStyle'; st.textContent='@keyframes riskPulse{0%,100%{filter:brightness(1)}50%{filter:brightness(1.35)}} .board.unsupervised .tile.risk{position:relative;}'; document.head.appendChild(st); } }
    function clearRisk(t){ t.classList.remove('risk'); t.style.outline=''; t.style.animation=''; delete t.dataset.risk; }
    function onTile(idx){ if(!state.running) return; const t=tiles()[idx]; if(!t) return; if(t.dataset.risk){ if(t.classList.contains('disabled')){ penalty(2,true); return; } state.score+=3; state.bonus+=3; clearRisk(t); message.textContent=texts[state.lang].risk; updateHud(); return; }
      if(t.classList.contains('disabled')) return; const decoy=t.dataset.decoy; if(decoy){ penalty(decoy==='heavy'?3:2,false); return; }
      state.total++; const seq= state.reverse? [...state.sequence].reverse(): state.sequence; const current=seq[state.inputIndex]; if(!current) return; if(current.type==='single'){ if(idx===current.v){ confirm(idx); correctAdvance(); } else fail(); } else { if(current.unsatisfied && current.unsatisfied.has(idx)){ current.unsatisfied.delete(idx); confirm(idx); highlight(idx,140,'pairing'); if(current.unsatisfied.size===0) correctAdvance(); } else fail(); } }
    function confirm(idx){ const t=tiles()[idx]; if(!t) return; t.classList.add('confirm'); setTimeout(()=> t.classList.remove('confirm'), state.calmMode?260:140); }
    function penalty(p,early){ state.score=Math.max(0,state.score-p); state.streak=0; state.flawless=false; message.textContent= p===3? texts[state.lang].penaltyHeavy : texts[state.lang].penalty; updateHud(); }
    function correctAdvance(){ state.inputIndex++; if(state.inputIndex===state.sequence.length){ cancelTimer(); const basePts= state.sequence.length*2 * state.multiplier; const speedRatio = state.timeRemaining / state.timeLimit; if(speedRatio>0.4){ const extra = Math.round(basePts * 0.25 * speedRatio); state.score+=extra; state.bonus+=extra; }
        state.multiplier = Math.min(5, state.multiplier + 0.08); state.score+= Math.round(basePts); updateHud(); flashMsg(texts[state.lang].next,600); setTimeout(nextLevel,600); } }
    function fail(){ state.running=false; cancelTimer(); flashMsg(texts[state.lang].fail,900); setTimeout(()=>{ resetGame(); },900); }
    function useHint(){ if(!state.running) return; if(state.hintsLeft<=0){ flashMsg(texts[state.lang].noHints,600); return; } state.hintsLeft--; state.hintCost+=2; updateHud(); const target = state.reverse? [...state.sequence].reverse()[state.inputIndex] : state.sequence[state.inputIndex]; if(!target) return; if(target.type==='single') highlight(target.v,450); else target.v.forEach(v=> highlight(v,450,'pairing')); }
    function startTimer(){ state.timeLimit = 4000 + state.sequence.length*900; state.timeRemaining=state.timeLimit; if(state.calmMode) state.timeLimit*=1.15; const start=performance.now(); function tick(){ const now=performance.now(); const elapsed=now-start; state.timeRemaining = Math.max(0,state.timeLimit - elapsed); const ratio= state.timeRemaining/state.timeLimit; timeFill.style.width = (ratio*100)+'%'; if(state.timeRemaining<=0){ state.running=false; flashMsg(texts[state.lang].timeFail,800); fail(); return; } if(state.running) state.timeRAF=requestAnimationFrame(tick); } state.timeRAF=requestAnimationFrame(tick); }
    function cancelTimer(){ if(state.timeRAF) cancelAnimationFrame(state.timeRAF); }
    // Controls
    const startBtn=btn(texts[state.lang].start,'start',()=>{ if(state.running) return; resetGame(); nextLevel(); }); controls.appendChild(startBtn);
    const hintBtn=btn('💡','',()=> useHint()); controls.appendChild(hintBtn);
    const calmBtn=btn(texts[state.lang].calm,'',()=>{ state.calmMode=!state.calmMode; calmBtn.textContent= state.calmMode? texts[state.lang].active:texts[state.lang].calm; }); controls.appendChild(calmBtn);
    const themeBtn=btn(texts[state.lang].theme,'',()=>{ state.theme= state.theme==='classic'?'neo':'classic'; board.dataset.theme=state.theme; themeBtn.textContent= state.theme==='classic'? texts[state.lang].neo : texts[state.lang].classic; }); controls.appendChild(themeBtn);
    return { destroy(){ state.destroyed=true; state.running=false; state.timeouts.forEach(clearTimeout); cancelTimer(); mount.innerHTML=''; } };
  }

  /* --------------------------------------------------
     Game registry & mounting
  -------------------------------------------------- */
  const GAME_META = {
    'memory-sequence': { version:'v1', title:'Memory Sequence', desc:{ en:'Follow and replicate an expanding color pattern. Focus & reaction.', es:'Sigue y replica un patrón de colores en expansión. Enfoque y reacción.' }, factory:createMemorySequenceGame },
    'memory-mapping': { version:'v1', title:'Memory Mapping', desc:{ en:'Pattern flashes then disappears. Rebuild by position.', es:'El patrón aparece y desaparece. Reconstrúyelo por posición.' }, factory:createMemoryMappingGame },
    'alz-jaime': { version:'v1', title:'Alz‑Jaime', desc:{ en:'Gentle progressive sequence with optional persistent hints.', es:'Secuencia progresiva suave con pistas persistentes opcionales.' }, factory:createAlzJaimeGame },
  'unsupervised-3d': { version:'v1', title:'Unsupervised 3D', desc:{ en:'Single-room 3D + Mahjong-like memory task (research mode).', es:'Sala única 3D + juego de memoria tipo Mahjong (modo investigación).' }, factory:createUnsupervised3DGame },
    'focus-pulse': { version:'v2', title:'Focus Pulse', desc:{ en:'Track shrinking pulse targets. Improves timing & attention.', es:'Sigue pulsos encogiendo. Mejora tiempo y atención.' }, factory: createFocusPulseGame },
    'ant-path': { version:'v3', title:'Ant Path', desc:{ en:'Guide the ant; collect apples, avoid chickens.', es:'Guía la hormiga; recoge manzanas evita gallinas.' }, factory:createAntPathGame },
    'unsupervised': { version:'v9', title:'The Unsupervised Game', desc:{ en:'Hybrid memory, mapping & reaction challenge. Agentic AI only.', es:'Reto híbrido memoria, mapeo y reacción. Solo IA agente.' }, factory:createUnsupervisedGame },
    'maze-3d': { version:'v4', title:'The Science Lab', desc:{ en:'Enhanced 3D scientific laboratory with helmet HUD & effects.', es:'Laboratorio científico 3D mejorado con HUD de casco y efectos.' }, factory:createRaycastGame }
  };

  let currentInstance=null; let currentKey='memory-sequence';
  function mountGame(key){ const meta=GAME_META[key]; if(!meta) return; currentKey=key; clearUI(); activeGameTitle.textContent=meta.title; const lang=document.documentElement.getAttribute('data-lang')||'en'; activeGameDesc.textContent= meta.desc[lang]; currentInstance = meta.factory({ mount:boardMount, statusBar, controls, message }); }

  // Re-create previously existing game factories from pasted truncated section
  function createFocusPulseGame(cfg){ return window.__focusPulseFactory? window.__focusPulseFactory(cfg): ( ()=>{ const m=document.createElement('div'); cfg.mount.appendChild(m); cfg.message.textContent='(Focus Pulse factory missing in truncated file)'; return {destroy(){}}; })(); }
  function createAntPathGame(cfg){ return window.__antPathFactory? window.__antPathFactory(cfg): ( ()=>{ const m=document.createElement('div'); cfg.mount.appendChild(m); cfg.message.textContent='(Ant Path factory missing)'; return {destroy(){}}; })(); }

  // Rebind original ones if they survived earlier part (they were truncated). In this repaired version we keep minimal placeholders above if lost.

  // Card interaction
  document.querySelectorAll('.game-card').forEach(card=>{
    card.addEventListener('click',()=> {
      if(card.dataset.game === 'maze-3d') {
        // Redirect to maze.html for the 3D Maze game
        window.location.href = 'maze.html';
        return;
      }
      selectGame(card.dataset.game);
    });
    card.addEventListener('keydown',e=>{ 
      if(e.key==='Enter' || e.key===' '){ 
        e.preventDefault(); 
        if(card.dataset.game === 'maze-3d') {
          // Redirect to maze.html for the 3D Maze game
          window.location.href = 'maze.html';
          return;
        }
        selectGame(card.dataset.game); 
      }
    });
  });
  function selectGame(key){ if(key===currentKey) return; document.querySelectorAll('.game-card').forEach(c=> c.classList.toggle('is-active', c.dataset.game===key)); if(currentInstance && currentInstance.destroy) currentInstance.destroy(); mountGame(key); }

  // Language switching (simplified)
  $('#gLangEn').addEventListener('click',()=>{ setLang('en'); });
  $('#gLangEs').addEventListener('click',()=>{ setLang('es'); });
  function setLang(l){ document.documentElement.setAttribute('data-lang',l); $('#gLangEn').setAttribute('aria-pressed', l==='en'); $('#gLangEs').setAttribute('aria-pressed', l==='es'); const meta=GAME_META[currentKey]; if(meta) activeGameDesc.textContent=meta.desc[l]; }

  function handleHash(){ if(!location.hash) return; const parts=location.hash.slice(1).split('&'); const key=parts[0]; if(GAME_META[key]){ selectGame(key); setTimeout(()=>{ if(parts.includes('autostart')){ const startBtn = document.querySelector('#controls .start'); if(startBtn) startBtn.click(); } },120); }
  }

  // Initial mount
  mountGame('memory-sequence');
  handleHash();
  window.addEventListener('hashchange', handleHash);
</script>
